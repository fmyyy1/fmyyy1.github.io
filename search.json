[{"title":"任意加载字节码下的回显","date":"2022-04-14T11:14:04.000Z","url":"/2022/04/14/%E4%BB%BB%E6%84%8F%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8B%E7%9A%84%E5%9B%9E%E6%98%BE/","categories":[["java","/categories/java/"]],"content":"任意加载字节码下的回显spring之前题目也用到过很多次了 简单看一下，先是从线程里获取类加载器，加载了org.springframework.web.context.request.RequestContextHolder springMVC中，为了方便随时获取当前的request对象，可以通过RequestContextHolder的静态方法getRequestAttributes()获取Request相关的变量，如request, response等。 知道org.springframework.web.context.request.RequestContextHolder的作用了，能获取到request和response了之后就很简单了。 tomcat之前学过tomcat有三种回显方式，基于linux文件描述符，基于ThreadLocal和全局存储的Response三种方式。这里就用第三种。 稍微改一下就能用了 总的就是这样： 可以写一段测试一下 效果 其他还有一个是虎符CTF ezchain的一个原生环境下的回显，这里不记了"},{"date":"2022-04-14T10:11:12.935Z","url":"/2022/04/14/test2/","categories":[["undefined",""]],"content":"这是一篇测试 "},{"title":"2022HFCTF-ezchain","date":"2022-04-12T08:14:04.000Z","url":"/2022/04/12/2022HFCTF_ezchain/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言比赛的时候没做出来，赛后复现了，隔了这么久想写一篇笔记顺便练习一下codeql 分析 Hessian+rome的反序列化 网上公开的hessan+rome最后是进行jndi注入的，但题目设置了不出网，所以不能利用。 rome原本的加载字节码的链子也是不能用，因为修饰符是transient，Hessian的反序列化并不会调用类的readObject方法对其恢复。 所以根据rome链终点的特性，找合适的setter或者getter方法。最后找到的是 java.security.SignedObject#getObject 里面有个原生的反序列化。 codeql寻找想练习一下codeql，知道终点之后只要写对规则就行了 jdk建库关于这个问题，实际上就是编译jdk的过程，只不过最后的步骤从编译jdk变成建codeql库，所以按照网上不同系统如何编译jdk的过程来就行了，最后一步编译jdk的时候在用codeql建库 编写第一版先来一个简单的版本，单纯从语法结构上来分析 前面说了终点是 java.security.SignedObject#getObject rome终点的特点就是调用无参的setter、getter和is方法 所以要求 1.get或set或is开头，无参数 2.调用readObject 最终： 第二版想试着用污点追踪找找看，准备简单定义一下，sink就是readObject 先写一下sink吧 readObject一般都是 a.readObject()的形式调用 所以sink这么写 接着是source，不知道怎么很好的去定义，暂时定义为ByteArrayInputStream方法，并且参数为成员变量,这里偷懒就找以this开头的 刚接触codeql不久。写的挺烂的，有点误报但还是能找到，就当练一下手吧 这里想减少误报就定义一下isAdditionalTaintStep吧。 回显问题现在能任意原生反序列化了，因为不出网所以最后得解决回显问题。这里借鉴feng师傅的 所以恶意类 所以最后 "},{"title":"字节码在fastjson中的应用","date":"2022-04-07T13:14:04.000Z","url":"/2022/04/07/%E5%AD%97%E8%8A%82%E7%A0%81%E5%9C%A8fastjson%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","categories":[["java","/categories/java/"]],"content":"字节码在fastjson中的应用看书的时候看到fastjson反序列化用的是ASM，所以想去自己看一下，估计这篇笔记有很多错误的地方。 版本是1.2.23，简单的代码就可以开始了 在进入字节码处理部分之前看到了几个有意思的点，在解析json的部分 首先看一下。是允许添加一些类似注释的东西的，例如 逻辑就在这一段 再然后是skipWhitespace，去除前部分空白字符和\\r、\\n、\\t、\\f、\\b这种字符 再之后是这一段 遇到逗号就再来一次skipWhitespace 所以如果开启了AllowArbitraryCommas（默认好像就是开启），就可以这么写, 不止逗号匹配到其他一些符号也会调用skipWhitespace，具体可以去看看源码 看到个ASMClassLoader，应该是fastjson自定义的类加载器 继续看吧。来到这里com.alibaba.fastjson.parser.DefaultJSONParser 此时的defaultClassLoader为null的 进入loadClass，这里面能看到一段重要的 这里就是fastjson1.2.25以上版本的绕过方法了，类名开头允许L、[ 结尾允许; 的存在 去Thread里尝试获取构造器。这里获取的是AppClassLoader 现在用AppClassLoader加载了我们的fastjson.User类，此时还没有生成实例 加载好类之后来到这里 之后调用到这，可以看到1.2.24版本的黑名单 之后是对类名进行一些校验的过程，主要是进入createJavaBeanDeserializer这个函数 前半部分尝试获取父类，然后对其进行一些校验，之后是对能否用asm解析进行校验，若可以则返回了一个asmFactory 最后就来到了 看到了熟悉的ClassWriter，接下来应该就是ASM处理过程了，有点复杂没仔细去看 之后回到javaBeanDeserializer.java，我们的User类生成实例的地方在这里 这里传入的是FastjsonASMDeserializer_1_User,是一个JavaBeanDeserializer类，是刚刚asm处理过程生成的 之后就是处理成员变量的过程了，也能看到调用setter getter，具体就不看了。"},{"title":"agent内存马简单学习","date":"2022-04-06T09:14:04.000Z","url":"/2022/04/06/agent%E5%86%85%E5%AD%98%E9%A9%AC/","categories":[["java","/categories/java/"]],"content":"agent内存马又是跟Instrument机制有关的知识。 思路我的理解是这样 Instrument机制允许动态修改程序，利用这个机制对org.apache.catalina.core.ApplicationFilterChain#doFilter进行字节码修改 原理上并不难，修改字节码用javassit即可 注入用spring搭建环境.放个cc的依赖 项目地址  主要实现是这块 利用javassist框架修改doFilter方法的字节码为我们的shell 之后主要问题是获得进程的pid，天下大木头师傅是这样获取的 注入的过程就不记了"},{"title":"jdk8+spring原生场景任意写文件rce","date":"2022-04-05T13:14:04.000Z","url":"/2022/04/05/jdk8+springboot%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6rce/","categories":[["java","/categories/java/"]],"content":"jdk8+spring原生场景任意写文件rce逛了一下三梦师傅的博客看到的，写一篇笔记。 写文件springboot把所有资源打包进jar，我们无法在运行时往classpath等目录写入内容。但是我们可以往系统的classpath目录写内容，即 JDK HOME 思路jvm不会把JDK HOME下的jar文件一次性全部加载进来。配合任意写文件的漏洞，我们可以替换JDK HOME目录下的系统 jar 文件，再主动触发 jar 文件里的类初始化来达到执行任意代码的方法。 覆盖哪一个jar文件呢？ 如果程序代码中没有使用Charset.forName(&quot;GBK&quot;)类似的代码，就不会加载到/jre/lib/charsets.jar 所以 覆盖charsets,jar即可，接下来要解决的是如何主动加载这个jar。 在org.springframework.web.accept.HeaderContentNegotiationStrategy#resolveMediaTypes spring都会尝试解析请求头中的ACCEPT，进入parseMediaTypes，经过一系列调用会来到MimeTypeUtils#parseMimeTypeInternal 关键是return new MimeType(type, subtype, parameters);，解析了ACCEPT后生成MimeType实例 进入checkParameters 看到了Charset.forName 举例来说： 会执行 实践Landgrey大佬的项目地址  也为我们准备好了jar文件，直接用就行 之后发包 看到log文件创建就说明成功 拓展 三梦师傅给了另外的一种思路，相比于覆盖charset.jar来说更稳定 是从Charset.forName的原理上来探究，最后找到了lookupViaProviders(charsetName)利用SPI机制加载类。"},{"title":"codeql学习小记-数据流","date":"2022-03-25T10:34:04.000Z","url":"/2022/03/25/codeql%E5%AD%A6%E4%B9%A0-4-%E6%95%B0%E6%8D%AE%E6%B5%81/","categories":[["codeql","/categories/codeql/"]],"content":"DataFlow模块官方文档写了如何在java中用数据流分析  这篇笔记算是简单翻译一下吧。 局部数据流使用局部数据流局部数据流库在模块DataFlow中。该模块定义了Node类，表示数据经过的任何元素。 Node又可以分为表达式节点（ExprNode）和参数节点（ParameterNode） 使用谓词asExper和asParameter在数据流节点和表达式节点/参数节点表示映射（或者使用谓词exprNode和parameterNode） 除此之外，还有个谓词localFlowStep(Node nodeFrom, Node nodeTo) 文档描述是 谓词localFlowStep(Node nodeFrom, Node nodeTo)保存着从节点nodeFrom到节点nodeTo的直接数据流。 可以使用+和*运算符递归的应用谓词，或者使用预定义的递归谓词localFlow，它等效于localFlowStep* 例如,可以直接找到从source到sink的数据流，有时甚至不需要多余的步骤 局部污点跟踪例如，我们要查找FileReader的参数，官方文档给的是下面的规则 做个小测试，测试代码 成功查询到了FileReader的参数”/etc/passwd” 但这个规则只是从语句结构上查询，并不能做到污点跟踪。 局部污点追踪的库都保存在模块 TaintTracking 类似于局部数据流，有个差不多的谓词localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) 举个例子，如果我改成这样 纯语法分析的话 结果是这样 文档给的规则： 这个规则可以通过局部数据流找到所有跟fileName参数相关的表达式 之后可以把结果变得更具体 下面这个规则可以查找传递给FileReader的public参数 下面规则可以查询对格式化字符串未进行硬编码的格式化函数的调用 全局数据流全局数据流是跟踪一整个项目的数据流，所以它比局部数据流更强大。但是也有缺点，全局数据流没有局部数据流精确，而且分析时需要耗费更多的内存。 使用全局数据流通过继承DataFlow::Configuration类来使用全局数据流 configuration定义了下面几个谓词 isSource—defines where data may flow from isSink—defines where data may flow to isBarrier—optional, restricts the data flow isAdditionalFlowStep—optional, adds additional flow steps 特征谓词MyDataFlowConfiguration()定义了configuration的名称，所以&quot;MyDataFlowConfiguration&quot;必须是独一无二的。 用谓词hasFlow(DataFlow::Node source, DataFlow::Node sink)分析数据流 使用全局污点跟踪继承``TaintTracking::Configuration`进行全局污点跟踪 同样的 定义了下面谓词 isSource—defines where taint may flow from isSink—defines where taint may flow to isSanitizer—optional, restricts the taint flow isAdditionalTaintStep—optional, adds additional taint steps 跟全局数据流相似，特征谓词 MyTaintTrackingConfiguration() 定义配置的唯一名称。 用谓词hasFlow(DataFlow::Node source, DataFlow::Node sink) 进行全局污点跟踪分析 还有一个class可以分析远程用户的source 这对发现安全问题很有帮助 "},{"date":"2022-03-18T18:16:28.542Z","url":"/2022/03/19/test/","categories":[["undefined",""]],"content":"测试这是一篇测试111"},{"title":"Instrument 学习","date":"2022-03-14T00:14:04.000Z","url":"/2022/03/14/Instrument%D1%A7%CF%B0/","categories":[["java","/categories/java/"]],"content":"Instrument 学习主要是解决jvm运行时类的重载。 InstrumentJDK从1.5版本引入了java.lang.instrument包，开发者可以更方便的实现字节码增强。 java.lang.instrument包的结构如下： 核心功能由接口java.lang.instrument.Instrumentation提供 使用方式instrumention有两种使用方式 第一种 通过jvm的启动参数-javaagent来启动，例如 java -javaagent:myagent.jar Mymain 需要MANIFEST.MF配合找到Agent入口类，这样JVM在加载时会先执行AgentMain类的premain方法，再执行JAVA本身的main方法。 这种方法仅限于main方法之前执行，局限较大，重点学一下第二种 第二种： jdk6之后引入了动态Attach Agent方案。instrument支持了在运行时对类定义的修改。要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransformer接口，定义一个类文件转换器。接口中的transform()方法会在类文件被加载时调用，而在transform方法里，我们可以利用上文中的ASM或Javassist对传入的字节码进行改写或替换，生成新的字节码数组后返回。 测试: 先写一个MyTestMain类，这是我们要去修改的类 目标是注入之后使foo return 50 首先创建maven项目agent-demo 先按照asm的方式创建MyClassVisitor和MyMethodVisitor MyMethodVisitor 创建MyClassFileTransformer AgentMain pom里还得设置一下 把agent-demo打包为jar，记下路径 之后创建attach-demo，创建MyAttachMain 运行MyTestMain，用jps记下pid，替换MyAttachMain里的id即可，运行MyAttachMain，回去查看MyTestMain就会发现已经修改成功： "},{"title":"字节码操作","date":"2022-03-12T11:14:04.000Z","url":"/2022/03/12/%E5%AD%97%E8%8A%82%E7%A0%81%E6%93%8D%E4%BD%9C/","categories":[["java","/categories/java/"]],"content":"字节码操作实践ASM对于需要手动操纵字节码的需求，可以使用ASM，它可以直接生产 .class字节码文件，也可以在类被加载入JVM之前动态修改类行为 ASM API有Core API和Tree API。 Core API可以类比SAX的方式解析XML，Tree API可以类比DOM方式解析XML。一般情况下都使用Core API 它有下面几个关键类： ClassReader：用于读取已经编译好的.class文件。 ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。 各种Visitor类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的MethodVisitor、用于访问类变量的FieldVisitor、用于访问注解的AnnotationVisitor等。为了实现AOP，重点要使用的是MethodVisitor。 ClassReader和ClassWriter都是继承ClassVisitor 一个Base类 目标：通过ASM增强后在process前输出start、后输出end。 首先需要定义两个类，一个是继承ClassVisitor的MyClassVisitor类，用于对字节码的visit以及修改； 另一个是Generator类，在这个类中定义ClassReader和ClassWriter，classReader读取字节码，然后交给MyClassVisitor类处理，处理完成后由ClassWriter写字节码并将旧的字节码替换掉。 Generator: MyClassVisitor 逻辑理解起来也不难。 Base里有两个方法，构造函数和process。process是我们要增强的方法。 visitMethod方法判断当前读到哪个方法，跳过构造方法 &lt;init&gt; 后，将需要被增强的方法交给内部类MyMethodVisitor来进行处理。 主要的操作就在这一片 MethodVisitor的visitCode方法，它会在ASM开始访问某一个方法的Code区时被调用，所以可以在这里添加前置操作 每当ASM访问到无参数指令时，都会调用MyMethodVisitor中的visitInsn方法，判断了当前指令是否为无参数的“return”指令，如果是就在它的前面添加一些指令。我们写void方法时一般没有return。这里其实涉及到在字节码层面，void方法会执行return指令。 具体实现就是visitXXXXInsn,中间的XXXX就是字节码指令，比如mv.visitLdcInsn(“end”)对应的操作码就是ldc “end”，即将字符串“end”压入栈。 运行Generator.main之后查看编译好的Base.class内容： 写一个Test测试 ASM工具ASM ByteCode Outline 算是一个辅助工具，利用ASM手写字节码时，需要利用一系列visitXXXXInsn()方法来写对应的助记符，所以需要先将每一行源代码转化为一个个的助记符，然后通过ASM的语法转换为visitXXXXInsn()这种写法。第一步将源码转化为助记符就已经够麻烦了，不熟悉字节码操作集合的话，需要我们将代码编译后再反编译，才能得到源代码对应的助记符。第二步利用ASM写字节码时，如何传参也很令人头疼。ASM社区也知道这两个问题，所以提供了这个工具 在idea里可以直接安装。 工具教程  是个非常非常好用的工具 Javassist比asm操作简单一点框架。ASM是在指令层次上操作字节码，而Javassist更强调源码层次 利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是ClassPool、CtClass、CtMethod、CtField这四个类： CtClass（compile-time class）：编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。 ClassPool：从开发视角来看，ClassPool是一张保存CtClass信息的HashTable，key为类名，value为类名对应的CtClass对象。当我们需要对某个类进行修改时，就是通过pool.getCtClass(“className”)方法从pool中获取到相应的CtClass。 CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。 跟之前一样，在process前面和后面插入start和end，实现起来更简单直观易懂。 参考"},{"title":"D^3CTF web部分wp","date":"2022-03-08T12:14:04.000Z","url":"/2022/03/08/d%5E3CTF%20web%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":" ## d3oj 提示是尝试用oct用户登陆，翻组件版本看到个合适的  编辑文章哪里很明显 shorter网上公开的只能缩短到2kjiang师傅正好不久前就给我看过这个rome的新链子结合许少的文章和jiang师傅的新rome链子可以缩短到一千多 ezsql存在el注入的地方，但把new过滤了，想到编码绕过。 这个正则可以绕，只要两个或两个以上的u即可，比如${\\uu006eew String(“123”)}直接spel注入，但直接传似乎是有符号问题？ 直接全部编码就好了 编码后 哈哈 赛后我hxd告诉我有个类可以直接执行不需要new$&#123;@jdk.jshell.JShell@create().eval(&#39;java.lang.Runtime.getRuntime().exec(&quot;&quot;)&#125; 学到了学到了"},{"title":"Spring IOC学习","date":"2022-03-07T11:14:04.000Z","url":"/2022/03/07/Spring-IOC/","categories":[["java","/categories/java/"]],"content":"Spring IOC学习Spring IOC这里需要注意的是，IOC和Spring IOC不能混为一谈，IOC是一种概念和设计思路，Spring实现了IOC的思想，是IOC的实践。 我们通常提到的Spring IOC，实际上是指Spring框架提供的IOC容器实现（IOC Container） IOC叫做控制反转，另一种说法是依赖注入。 IOC的作用简单来说，就是控制对象的创建和销毁。控制和销毁本来是由用户控制的，用了IOC之后用户只需要去关注业务需求。 反转的概念： 正转指的是对象去找实例(Object o = new Object();)，反转就是实例去找对象，通过容器去找对象。 依赖： 在spring项目中，将对象理解为Bean，也可以叫bean对象，这个bean和容器之间有个依赖关系，bean对象的创建是依赖容器的，就好像孩子依赖父母一样，孩子不能自己生出自己，需要父母的合作才能出生，这里的孩子就是bean，父母就是容器 注入： 通过容器注入了bean对象，而且这个过程是自动化的，也就是说容器会自动找到和bean对象匹配的类型实例注入到对象中； Spring IOC加载流程流程 1、先是通过BeanDefinitionReader读取配置文件，生成bean的信息。BeanDefinition对象是完整的bean定义信息。这里只是存储bean的定义信息还没有实例化bean对象。 2、在 BeanDefinition 和 完整BeanDefinition 中间通过一个后置增强器，可以对bean的定义信息进行统一修改，只需要实现 BeanFactoryPostProcessor 接口即可，这个后置增强器是可以有多个的，你只要在不同的类实现多个 BeanFactoryPostProcessor 接口就会执行多次，就像这样： 3、得到完整BeanDefinition之后就可以进行创建对象了，这整个过程被称为 bean 的生命周期，也就是从实例化到销毁的过程； FactoryBean和BeanFactory区别BeanFactory直译是生产Bean的工厂，在Spring中就是容器，常用的ApplicationContext就是它的一个继承类.而FactoryBean顾名思义就是一个bean，但这个bean和普通bean有点不一样。 区分FactoryBean和普通Bean​ Spring中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean即FactoryBean，这两种Bean都被容器管理。工厂Bean是实现了org.springframework.beans.factory.FactoryBean接口的Bean,从ApplicationContext的getBean()方法获取的对象不是该类的一个实例，而是该类的getObject()方法所返回的对象。 当我们需要获取FactoryBean实例本身而不是它所产生的bean，则要使用&amp;符号。 比如，现有FactoryBean，id为“playerBean”，在容器上调用getBean(“playerBean”)将返回FactoryBean产生的bean。调用getBean(“&amp;playerBean”)将返回FactoryBean它本身的实例。 ApplicationContext 接口 BeanFactory 和 ApplicationContext 都是用来从容器中获取 Spring beans 的，但是，他们二者有很大不同 如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了。 ApplicationContext继承了BeanFactory（ListableBeanFactory, HierarchicalBeanFactory），所以它拥有更完善的功能，支持大型的业务。 两者获取bean的区别，举例 Beans.xml BeanFactory 和 ApplicationContext怎么获取他？ BeanFactory： ApplicationContext： 看起来是差不多，但他们的加载方式是不同的。 BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。 bean的生命周期 总结简单的学一下，主要是看这位大神的文章，从源码的角度讲，写的特别详细 "},{"title":"Tomcat几种回显","date":"2022-03-06T11:14:04.000Z","url":"/2022/03/06/TomcatEcho/","categories":[["java","/categories/java/"]],"content":"Tomcat几种回显文件描述符回显00theway师傅的思路  在LINUX环境下，可以通过文件描述符”/proc/self/fd/i”获取到网络连接，在java中我们可以直接通过文件描述符获取到一个Stream对象，对当前网络连接进行读写操作，可以釜底抽薪在根源上解决回显问题。 只要获取当前请求的对应进程的文件描述符，在输出描述符中写入内容就能够回显。 如何获得描述符？ 可以通过下面的命令获取 整合之后是这样 在实际使用过程中注意把客户端IP地址转换成16进制字节倒序，替换xxxx字符串。 这一段简单逻辑：执行获取描述符的命令，存入num。通过反射获取了FileDescriptor的构造器，参数为num，之后反射实例化，通过wirte方法写入我们执行的&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;ls /&quot;的内容达到回显。 通过ThreadLocal Response回显kingkk师傅的思路  整合之后 思路： 1.通过翻阅函数调用栈寻找存储Response的类 2.最好是个静态变量，这样不需要获取对应的实例，毕竟获取对象还是挺麻烦的 3.使用ThreadLocal保存的变量，在获取的时候更加方便，不会有什么错误 4.修复原有输出，通过分析源码找到问题所在 这里涉及到通过反射修改private static final修饰的属性，参考下面的文章。  因为自身基础问题，学习之前还不知道ThreadLocal类的作用，可以参考下面文章。  但简单来说ThreadLocal可以在一个线程中传递同一个对象。利用此特点获取我们要的response。 ApplicationFilterChain类的internalDoFilter有对ThreadLocal的赋值操作 拆开看 这一段是通过反射来改变private static final值的过程，这里还没有赋值 这一段从lastServicedResponse变量中获取tomcat Response变量 这里初始化ApplicationDispathcer中的lastServicedResponse变量为ThreadLocal，先判断是否为null，不是null就不要初始化。 之后是Response类的getWriter的一个问题， 文档描述： 看上方文档描述。如果已经调用过getWriter则再次调用会报错，判断方法是如果 usingWriter是true则已经调用过 所以需要反射修改usingWriter的值，对应的就是下面 整合之后就是我们最上面放的回显。 通过全局存储 Response回显 是在org.apache.coyote.http11.Http11Processor中 "},{"title":"《深入理解java虚拟机》读书笔记1-类文件结构","date":"2022-03-01T11:14:04.000Z","url":"/2022/03/01/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","categories":[["java","/categories/java/"]],"content":"《深入理解java虚拟机》读书笔记1-类文件结构最近在看周志明老师写的《深入理解java虚拟机》，学到了很多，也有很多没理解的地方，觉得需要做读书笔记。 无关性基石java虚拟机不与包括java语言在内的任何程序语言绑定，直至今日，商业企业和开源机构已经在java语言之外发展出一大批运行在java虚拟机之上的语言，比如Kotlin、Clojure、Groovy、JRuby、JPython、Scala等。java虚拟机它只与”calss文件“这种特定的二进制文件格式所关联。class文件中包含了java虚拟机指令集、符号表以及若干其他辅助信息。 class类文件结构java技术能够一直保持着非常良好的向后兼容性，class文件结构的稳定性功不可没。 Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割 成若干个8个字节进行存储。 类文件结构表格： 魔数 每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件。 其值为 0xCAFEBABY（咖啡宝贝？） 版本号紧接着魔数的4个字节存储的是Class文件的版本号:第5和第6个字节是次版本号（Minor Version)，第七第八字节是主版本号(Major Version) 比如我这里此版本号为0x0000，而主版本号为0x0034，转换为10进制则为52，对照表格说明我这是可以被jdk8以上或以上版本的虚拟机执行的class文件 常量池紧接着主、次版本号之后的是常量池入口，常量池（constant_pool）可以比喻为Class文件里的资源仓库。 在常量池之前还有一项u2类型的数据，代表着常量池容量计数值（constant_pool_count) 书中描述： 与Java中语言习惯不同，这个容量计数是从1而不是0开始 的，如图6-3所示，常量池容量(偏移地址:0x00000008)为十六进制数0x0016，即十进制的22，这就 代表常量池中有21项常量，索引值范围为1~21。在Class文件格式规范制定之时，设计者将第0项常量 空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下 需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。Class文件结构中只有 常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的 容量计数都与一般习惯相同，是从0开始。 常量池中主要存放两大类常量:字面量(Literal)和符号引用(Symbolic References)。字面量比 较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译 原理方面的概念。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。 常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量[1]，为了支持Java模块化系统 (Jigsaw)，又加入了CONSTANT_M odule_info和CONSTANT_Package_info两个常量，所以截至JDK 13，常量表中分别有17种不同类型的常量。 每一项常量都是一个表。java自带的javap命令可以输出常量表。 书中还有更具体的分析，但篇幅太长。感兴趣可以去看看书。 访问标志常量池之后的两个字节代表访问标志（access_flags），用于识别类或者接口层次的访问信息。 我这里的hello.class只是一个普通的class，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而ACC_FINAL、ACC_INTERFACE、 ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_MODULE这七 个标志应当为假，因此它的access_flags的值应为:0x0001|0x0020=0x0021 类索引、父类索引和接口索引集合类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合 (interfaces)是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。 字段表集合字段表(field_info)用于描述接口或者类中声明的变量。Java语言中的“字段”(Field)包括类级变 量以及实例级变量，但不包括在方法内部声明的局部变量。 字段可以包括的修饰符有字段的作用域(public、privat e、protected修饰符)、是实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile修饰符，是否强制从主内存读写)、可否被序列化(transient修饰符)、字段数据类型(基本类型、对象、数组)、 字段名称。 字段修饰符放在access_flags中，他跟前面的访问标志挺像的。 由于语法规则的约束，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有 ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所导致的。 在access_flags之后的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。具体可以看书，放一张书中的表格。 之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。 方法表集合Class文件存储 格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，仅在访问标志和属性表集合的可选项中有所区别。依次包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descrip tor_index)、属性表集合(attributes)几项 因为volatile关键字和transient 关键字不能修饰方法，所以方法表的访问标志中没有了 ACC_VOLATILE标志和ACC_TRANSIENT标志。 如图， 第一个0x0001表示methods_count 第二个0x0001表示access_flags 0x0007表示name_index 0x0008表示descriptor_index 最后的0x0001和0x0009分别表示attributes_count和attribute_name_index 属性表（attribute_info）集合这一节是书中表示类文件结构篇幅最长的，这里简单记一下。 与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一 些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。 code属性Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内 Exceptions属性Exceptions属性的作用是列举出方法中可能抛出的受查异常(Checked Excepitons)，也 就是方法描述时在throws关键字后面列举的异常。 LineNumberTable属性LineNumberTable属性用于描述Java源码行号与字节码行号(字节码的偏移量)之间的对应关系。 LocalVariableTable及LocalVariableTypeTable属性LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。 SourceFile及 SourceDebugExtension属性SourceFile属性用于记录生成这个Class文件的源码文件名称。 ConstantValue属性ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量(类变量)才可以使用这项属性。 InnerClasses属性InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。 Deprecated及Synthetic属性Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。 StackMapTable属性StackMapTable属性在JDK6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code 属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器(TypeChecker)使用(详见第7章字节码验证部分)，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 Signature属性Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。在JDK5里面大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(Type Variable)或参数化类型(Parameterized Type)，则Signature属性会为它记录泛型签名信息。 BootstrapMethods属性BootstrapMethods属性在JDK 7时增加到Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedy namic指令引用的引导方法限定符。 MethodParameters属性MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。 MethodParameters的作用是记录方法的各个形参名称和信息。 模块化相关属性JDK 9的一个重量级功能是Java的模块化功能，因为模块描述文件(module-info.java)最终是要编译成一个独立的Class文件来存储的，所以，Class文件格式也扩展了Module、ModulePackages和 ModuleMainClass三个属性用于支持Java模块化相关功能。 书中有对每一个属性的具体结构和作用有详细的分析，但篇幅太长就不记在笔记里了。"},{"title":"Tomcat学习","date":"2022-02-26T11:14:04.000Z","url":"/2022/02/26/Tomcat%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/","categories":[["java","/categories/java/"]],"content":"Tomcat学习tomcat结构图 两个核心组件ConnectorConnector 连接器 Connector组件是负责生成请求对象和响应对象的，Tomcat默认的是HttpConnector，负责根据收到的Http请求报文生成Request对象和Response对象，并把这两个对象传递给Container，然后根据Response中的内容生成相应的HTTP报文。 监听网络端口。 接受网络连接请求。 读取请求网络字节流。 根据具体应用层协议（HTTP/AJP）解析字节流，生成统一的 Tomcat Request 对象。 将 Tomcat Request 对象转成标准的 ServletRequest。 调用 Servlet容器，得到 ServletResponse。 将 ServletResponse转成 Tomcat Response 对象。 将 Tomcat Response 转成网络字节流。 将响应字节流写回给浏览器。 同时为了解决Tomcat使用Request存放请求信息 而不是标准的ServletRequest这个问题，引入适配器模式，提供CoyoteAdapter，连接器调用 CoyoteAdapter 的 Sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter负责将 Tomcat Request 转成 ServletRequest，再调用容器的 Service方法。 Container Container中还有四种容器，分别是 Engine、Host、Context和 Wrapper。 一个 Host 多个 Context， 一个 Context 也包含多个 Servlet，而每个组件都需要统一生命周期管理，所以组合模式设计这些容器。 Engine: 最顶层容器组件，可以包含多个Host。实现类为org.apache.catalina.core.StandardEngine Host: 代表一个虚拟主机，每个虚拟主机和某个域名Domain Name相匹配，可以包含多个Context。实现类为org.apache.catalina.core.StandardHost Context: 一个Context对应于一个Web 应用，可以包含多个Wrapper。实现类为org.apache.catalina.core.StandardContext Wrapper: 一个Wrapper对应一个Servlet。负责管理 Servlet ，包括Servlet的装载、初始化、执行以及资源回收。实现类为org.apache.catalina.core.StandardWrapper 从请求如何定位到Servlet来看这几个容器的作用， Mapper 组件的功能就是将用户请求的 URL 定位到一个 Servlet，它的工作原理是：Mapper组件里保存了 Web 应用的配置信息，其实就是容器组件与访问路径的映射关系，比如 Host容器里配置的域名、Context容器里的 Web应用路径，以及 Wrapper容器里 Servlet 映射的路径，可以想象这些配置信息就是一个多层次的 Map。 首先根据协议和端口号确定 Service 和 Engine。（Engine容器用于从 Connector 组件处接收已建立的 TCP 连接，还用于接收客户端发送的 HTTP 请求并分析请求，然后按照分析的结果将相关参数传递给匹配出的虚拟主机。） 根据域名选定 Host。（Host 容器定义虚拟主机，对应了服务器中一个网络名实体（如”www.baidu.com”，或IP地址”23.0.32.1”）。为了使用户可以通过域名连接 Tomcat 服务器，这个域名应该在域名服务器已经注册过。） 根据 URL 路径找到 Context 组件。（Context 容器主要是根据 path 和 docBase 获取一些信息，将结果交给其内的 wrapper 组件进行处理（它提供wrapper运行的环境，所以它叫上下文context）。） 根据 URL 路径找到 Wrapper（Servlet）。（wrapper 容器对应 Servlet 的处理过程。它开启 Servlet 的生命周期，根据 Context 给出的信息以及解析 web.xml 中的映射关系，负责装载相关的类，初始化 servlet 对象 init()、执行 servlet 代码 service() 以及服务结束时 servlet 对象的销毁 destory()。） Context这里想学一下Context这个组件，因为在内存马和回显里都遇到过。 每一个Context都有唯一的path。这里的path不是指servlet绑定的WebServlet地址，而是指独立的一个Web应用地址。就好比Tomat默认的/地址和/manager地址就是两个不同的web应用，所以对应两个不同的Context。要添加Context需要在server.xml中配置docbase。 如下图所示， 在一个web应用中创建了2个servlet服务，WebServlet地址分别是/Demo1和/Demo2。 因为它们属于同一个Web应用所以Context一样，但访问地址不一样所以Wrapper不一样。/manager访问的Web应用是Tomcat默认的管理页面，是另外一个独立的web应用， 所以Context与前两个不一样。 三种contextTomcat中有三种Context ServletContext、StandardContext、ApplicationContext ServerletContext（是一个接口） 通过request.getServletContext() 获取到的是ApplicationContextFacade对象，它是对ServerletContext接口的实现类，该类提供了Web应用所有Servlet的视图，可以对某个Web应用的各种资源和功能进行访问。 WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext。它代表当前Web应用，并且它被所有客户端共享。 ApplicationContext ApplicationContext也是对ServerletContext接口的实现类，由上图可知该类被包装在ApplicationContextFacade类中。 StandardContext org.apache.catalina.Context接口的默认实现为StandardContext，而Context在Tomcat中代表一个web应用。ApplicationContext所实现的方法其实都是调用的StandardContext中的方法，StandardContext是Tomcat中真正起作用的Context。 "},{"title":"jndi加载本地class绕过高版本限制","date":"2022-02-22T11:14:04.000Z","url":"/2022/02/22/jndi%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0class%E7%BB%95%E8%BF%87%E9%AB%98%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6/","categories":[["java","/categories/java/"]],"content":"jndi加载本地class绕过高版本限制前言两个月前做[NPUCTF2020]EzShiro的时候遇到过，是一个jackson的反序列化，但题目的jdk版本过高导致无法远程加载恶意class，所以得加载本地class。 当时用的是ysomap一键搭恶意服务。 高版本限制rmi和ldap都是返回一个Reference对象，受害端解码这个Reference时会去我们指定的Codebase远程地址加载Factory类。ldap的限制比rmi的更少，因此范围更广。但在高版本的jdk中对这两个服务都做了一些限制。 对于rmi来说：在JDK 6u132,JDK 7u122,JDK 8u113 中Java提升了JNDI 限制了Naming/Directory服务中JNDI Reference远程加载Object Factory类的特性。系统属性com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false，即默认不允许从远程的Codebase加载Reference工厂类。如果需要开启RMI Registry或者COS Naming Service Provider的远程类加载功能，需要将前面说的两个属性值设置为true。 对于jndi来说：在Oracle JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false 绕过所以对于Oracle JDK 11.0.1、8u191、7u201、6u211或者更高版本的JDK来说，默认环境下之前这些利用方式都已经失效。然而，我们依然可以进行绕过并完成利用。两种绕过方法如下： 找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。 利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 JRMP：空指针-treasure-Writeup 这三种方式都依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。 利用本地Class作为Reference Factory绕过高版本限制不想创建javaweb项目的话可以在maven里导两个依赖 Server 封装了我们构造的resourceRef并且绑定服务 Client 这个方法适用于tomcat8以上环境 关键是org.apache.naming.factory.BeanFactory类 先调试 来到javax.naming.spi.NamingManager类，这个类在学jndi时学过。 获取到了org.apache.naming.factory.BeanFactory的Reference，之后进入到了BeanFactory的getObjectInstance方法 这里判断是否为ResourceRef类也就是我们封装的类，之后就是加载类的过程，被加载的类为javax.el.ELProcessor 通过反射实例化，进入ref.get(“forceString”),取出键值为forceString的值，拆分之后存入hashmap 所以我们的Server里时这样构造的 反射执行 这里是因为在javax.el.ELProcessor类中的eval方法能执行el表达式。 利用LDAP返回序列化数据，触发本地Gadget绕过高版本限制上面说了高版本jdk中增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项。但还可以利用ldap加载本地的Gadget 假设目标环境存在Commons-Collections-3.2.1包，且存在JNDI的lookup()注入或Fastjson反序列化漏洞。 yso生成一下payload就可以测试 Server 调用栈 看到了原生的反序列化 在decodeObject中用getCodebases方法获取JAVA_ATTRIBUTES索引为4的内容 这里没有设置即为null，即var1为null 之后获取索引为1的内容即为javaSerializedData，这个我们是在恶意LDAP服务端中设置了的、内容就是恶意的Commons-Collections这个Gadget的恶意利用序列化对象字节流，对应的就是var2，之后通过getURLClassLoader()获得类构造器进入后面deserializeObject进行反序列化。 为什么高版本不能远程加载任意类呢？ 在helper.getURLClassLoader方法中 trustURLCodebase默认false，无法满足判断。"},{"title":"weblogic-CVE-2017-10271","date":"2022-02-21T11:14:04.000Z","url":"/2022/02/21/weblogic-CVE-2017-10271/","categories":[["java","/categories/java/"]],"content":"weblogic-CVE-2017-10271环境搭建关于weblogic环境搭建，非常推荐qax的一个工具  CVE-2017-10271Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。攻击者发送精心构造的xml数据甚至能通过反弹shell拿到权限。 影响版本 10.3.6.0.0，12.1.3.0.0，12.2.1.1.0，12.2.1.2.0 下面地址貌似都可触发 复现数据包 分析终点WorkContextXmlInputAdapter 调用栈 ![image-20220221120623417](/Users/fmyyy/Library/Application Support/typora-user-images/image-20220221120623417.png) weblogic.wsee.jaxws.workcontext.WorkContextServerTube#processRequest处理我们的请求数据 之后进入readHeaderOld 最后就到了WorkContextXmlInputAdapter反序列化了xml数据。"},{"title":"Express+lodash+ejs原型链污染RCE","date":"2022-02-17T01:14:04.000Z","url":"/2022/02/17/loadsh+ejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","categories":[["nodejs","/categories/nodejs/"]],"content":"Express+lodash+ejs原型链污染RCElodash.defaultsDeep 方法造成的原型链污染（CVE-2019-10744）2019 年 7 月 2 日，Snyk 发布了一个高严重性原型污染安全漏洞（CVE-2019-10744），影响了小于 4.17.12 的所有版本的 lodash。 Lodash 库中的 defaultsDeep 函数可能会被包含 constructor 的 Payload 诱骗添加或修改Object.prototype 原型链-&gt;RCE简单的应用 断点res.render(‘index’);调试之后来到ejs库的compile函数 这里有个命令注入，outputFunctionName默认undefined，利用lodash.defaultsDeep污染outputFunctionName键，造成命令注入。 payload &#123;&quot;type&quot;:&quot;constructor&quot;,&quot;content&quot;:&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;open -a calculator&#39;);//&quot;&#125;&#125;&#125;&#125; 污染之后 post之后get访问/触发render "},{"title":"CVE-2022-21824-console.table原型链污染","date":"2022-02-16T11:14:04.000Z","url":"/2022/02/16/CVE-2022-21824/","categories":[["漏洞复现","/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"]],"content":"CVE-2022-21824这次Dice2022和vnctf2022都出了过相关的题目 描述 其实就是说console.table也能污染原型链了，但是危害很小，因为只允许将空字符串分配给对象原型的数字键。 本地调试之后，其实就是将Object.prototype[0]变成空字符 这样污染之后输出Object.prototype[0]就为空字符串而不是undefined VNCTF2022 newcalc0源码 有个vm2，也逃逸不了，利用上面的cve污染一下 满足flag路由的if(Object.keys(Object.prototype).length &gt; 0) console.table([&#123;&#125;], [&quot;__proto__&quot;]); 之后访问flag "},{"title":"log4j","date":"2022-02-15T01:14:04.000Z","url":"/2022/02/15/log4j/","categories":[["java","/categories/java/"]],"content":"前言这个漏洞杀伤力有目共睹。很感兴趣，拖了这么久来学习一下。 漏洞简介编号 CVE-2021-44228 Apache Log4j2是一个基于Java的日志记录工具。由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。 漏洞适用版本为2.0 &lt;= Apache log4j2 &lt;= 2.14.1，只需检测Java应用是否引入log4j-core这个jar。若存在应用使用，极大可能会受到影响。 复现添加maven依赖 poc 顺带一题 logger组件的debug、info、warn、error、fatal方法都能触发 分析最后是在org.apache.logging.log4j.core.lookup.StrSubstitutor.resolveVariable方法进行lookup 调用栈，最先是调用了该类的replace方法进而到lookup payload的格式问题在这里就解答了，在MessagePatternConverter的format方法里，匹配到$&#123;则进行replace 需要了解下lo4j三大组件 Logger：日志记录器，负责收集处理日志记录 Appender：日志存放的地方，负责日志的输出 Layout：日志格式化，负责日志输出的形式 在调用栈里面我们也能具体看到三个组件 一个event Logger倒是很好理解，收集日志，poc起点就是这个组件，payload被这个组件收集。 之后是LoggerConfig.processLogEvent()用来处理日志事件，会调用callAppenders Appender主要将日志传送到输出目标，这里用的ConsoleAppender是输出到控制台 之后输出日志则需要用到layout组件，将日志encode了一下就去处理输出格式，问题出在输出格式的地方，回到刚刚上面我放的源码截图就知道，在format函数里匹配到$&#123;就去调用StringBuilder.append,里面调用上面提到的replace直到jndi注入 在我的理解看来就是： 调用error fatal这种函数尝试输出错误信息，logger负责收集事件，appender储存事件并指定输出，要么是控制台输出（Consoleappender）要么文件输出，layout就是具体负责输出的，但这中间有个输出格式处理，问题就出在格式处理这边，匹配到${就去jndi了 RC1绕过待补充"},{"title":"Dubbo HttpInvokerServiceExporter反序列化","date":"2022-02-13T11:14:04.000Z","url":"/2022/02/13/Dubbo%20HttpInvokerServiceExporter%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"Dubbo HttpInvokerServiceExporter反序列化漏洞Dubbo简介Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC(一种远程调用) 分布式服务框架(SOA)，致力于 提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。dubbo 支持多种序列化方式并 且序列化是和协议相对应的。比如:Dubbo支持dubbo、rmi、hessian、http、webservice、thrift、 redis等多种协议。 环境搭建源码我这边环境是mac dubbo源码地址  git下来,我们只需要dubbo-samples-http这一个项目就够了，idea打开其pom.xml即可，但为了复现得改一下版本,在pom.xml里直接添加（为了测试漏洞） 注册中心安装zookeeper下载，不知道为什么国内镜像都挂了，这个下起来贼慢  解压后在conf文件夹创建zoo.cfg，在里面复制以下内容 之后按系统环境启动zkServer即可 漏洞复现漏洞编号CVE-2019-17564 影响版本 Apache Dubbo 2.7.0 to 2.7.4； Apache Dubbo 2.6.0 to 2.6.7； Apache Dubbo all 2.5.x； 运行HttpProvider，出现dubbo service started表示成功 yso生成payload 这里有个问题，直接生成再用bp导入还是会有编码问题 所以可以把payload base64编码一下 之后python写个发包 报错信息 起点是HttpServlet类的service方法 获取HttpHandler，若NULL则返回404，不为NULL则进入handle 获取uri，为POST方法则设置RPC服务，然后调用HttpInvokerServiceExporter类对象skeleton的handleRequest()函数进一步处理请求，这里Content-Type为application/x-java-serialized-object即Java序列化数据类型： 之后获取了POST的数据，进入handleRequest函数中，一路调用到doReadRemoteInvocation 然后对我们post的数据做java原生反序列化触发命令执行。 "},{"title":"PWN学习-栈溢出基础","date":"2022-02-09T01:14:04.000Z","url":"/2022/02/09/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/","categories":[["PWN","/categories/PWN/"]],"content":"栈溢出基础三个重要的寄存器 EBP : 用来存储当前函数状态的基地址, 在函数运行时不变, 可以用来索引确定函数参数或局部变量的位置 ESP : 用来存储函数调用栈的栈顶地址, 在压栈和退栈时发生变化 EIP : 用来存储即将执行的程序指令的地址, cpu 依照 EIP 的存储内容读取指令并执行, EIP 随之指向相邻的下一条指令 栈溢出原理栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变 用一张图概括就是 简单的例子 篡改返回地址为目的函数地址即可。 实践 上面这样一个c语言程序，success就是一个后门函数，我们通过栈溢出篡改返回地址为success。 编译一下 其中-m32是生成32位程序，-fno-stack-protector是不开启堆栈溢出的保护（不生成canary）-no-pie是关闭PIE。 没有canary和pie,开启了NX，NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 放IDA调试 看存在溢出的vulnerable函数，双击s 所以s字符串离当前的栈底有20个字节的距离。 success函数地址为804846B 我们利用gets溢出覆盖返回地址位success地址即可getshell 思路：先用20个字符填满s到ebp之间的内容，然后是4字节ebp的内容。 写EXP "},{"title":"Listener内存马","date":"2022-02-08T11:14:04.000Z","url":"/2022/02/08/Listener%E5%86%85%E5%AD%98%E9%A9%AC/","categories":[["java","/categories/java/"]],"content":"Listener内存马Tomcat中的Listener是用于监听web常见对象HttpServletRequest,HttpSession,ServletContext 1.监听web对象创建与销毁. 2.监听web对象的属性变化 3.监听session绑定javaBean操作. 监听ServletRequest 域对象的创建与销毁最方便触发使用 其实主要研究的就是不利用web.xml注册Listener的问题。 例如下面的例子 之后在web.xml中注册这个Listener 之后就可以执行任意命令  但在实战中肯定是不能修改web.xml的，得想别的办法注册Listener，首先需要捋清楚 Tomcat 中 Listener 的注册流程。 Tomcat有两个Listener接口，org.apache.catalina.LifecycleListener 和原生 java.util.EvenListener 。 org.apache.catalina.LifecycleListener多用于tomcat启动阶段，此时客户端还没解析，所以不适用。 ServletRequestListener接口继承自EvenListener，直接看其名字就知道是一个监听Servlet请求的Listener，可以拦截外部提交的参数，很适合做内存马。 注册流程在StandardContext#listenerStart方法里，根据名称实例化我们自定义的Listener 之后在该类的fireRequestInitEvent方法里调用Listener的requestInitialized方法 回到前面，看一下Listener的名称是这么来的 是findApplicationListeners方法的返回值，这个方法return了this.applicationListeners，是一个字符串数组，存放了自定义Listener的名称 Listener的名称是解析web.xml得来的，tomcat解析web.xml的过程我想之后再记一篇笔记。 之后是通过getApplicationEventListeners和setApplicationEventListeners方法将实例化的Listener存放在applicationEventListenersList数组中。 内存马编写所以流程就是 1.获取StandardContext对象 2.调用其addApplicationEventListener方法往applicationEventListenersList数组里添加我们实例化的Listener 关于第一步如何获取StandardContext 这篇参考文章总结的很全面  所以一个完整的Listener内存马 "},{"title":"CVE-2021-2471","date":"2022-02-08T01:14:04.000Z","url":"/2022/02/08/CVE-2021-2471/","categories":[["漏洞复现","/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"]],"content":"CVE-2021-2471 这个漏洞是由于MySQL JDBC 8.0.27版本之前，存在getSource()方法未对传入的XML数据做校验，导致攻击者可以在XML数据中引入外部实体，造成XXE攻击。 分析在com.mysql.cj.jdbc.MysqlSQLXML.getSource()方法里 看一下直接解析了xml数据没有过滤，看一下stringRep怎么来的。 在该类的setString方法赋值。调用之后正好将fromResultSet也变为false 复现SQLXML对象可以如此获得 POC 修复在8.0.27之后该漏洞就修复了 做了很多校验，没法任意解析xml数据了。"},{"title":"Hessian反序列化","date":"2022-02-07T01:14:04.000Z","url":"/2022/02/07/hessian%E5%8F%8D%E7%B3%BB%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"Hessian反序列化Hessian简介Hessian是二进制的web service协议，官方对Java、Flash/Flex、Python、C++、.NET C#等多种语言都进行了实现。Hessian和Axis、XFire都能实现web service方式的远程方法调用，区别是Hessian是二进制协议，Axis、XFire则是SOAP协议，所以从性能上说Hessian远优于后两者，并且Hessian的JAVA使用方法非常简单。它使用Java语言接口定义了远程对象，集合了序列化/反序列化和RMI功能。本文主要讲解Hessian的序列化/反序列化 反序列化过程下面参考链接对Hessian反序列化的流程写的非常的详细易懂。  不过我觉得有意思的是验证对象是否存在readResolve方法这个地方。 看参考文章里的链接描述是 验证时是先反序列化对象，之后查询该对象是否存在readResolve方法，如果有的话则调用并且似乎是直接释放了对象，没有的话则直接返回该对象。 比如我这样改 之后尝试调用方法则会报错 或者改成String类 则会这样报错 所以类的readResolve方法在hessian反序列化里还是很重要的。 gadgets现在网上一共有5条gadget RomeRome链是老熟人了，之前做ctf题遇到过。 不过这里起点都是相同的，终点则是com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData进行jndi注入 调用connect之后就是lookup然后jndi注入了 对着yso的链子写了个poc 大体上跟原来那个加载字节码的rome差不多，但仍有一些有意思的细节 实际上弹出了两个计算器 这是因为这一句 map.put(equalsBean,&quot;fmyyy&quot;); put调用key的hashCode也算是经典了。Rmoe链的起点就是如此，所以也算是完整的调用了一次链子。 还有一点就是这句 jdbcRowSet.setMatchColumn(&quot;foo&quot;); 注释掉该句之后则无法获取到getDatabaseMetaData方法 为此回去重新仔细跟了一次rome链子,他获取方法名的简单逻辑是匹配到该类setter，getter，is方法，若无参则调用。 但是getMatchColumnNames是在我们目标方法getDatabaseMetaData前一个调用，若strMatchColumns属性值为null则报错 跳出了循环，之后的方法无法执行，所以先调用其set方法给该属性赋值防止报错。 SpringPartiallyComparableAdvisorHolder待补充 Resin待补充"},{"title":"java反序列化脏数据绕waf的技巧","date":"2022-02-05T13:14:04.000Z","url":"/2022/02/05/java%E5%88%A9%E7%94%A8%E8%84%8F%E6%95%B0%E6%8D%AE%E7%BB%95waf/","categories":[["java","/categories/java/"]],"content":"java反序列化脏数据绕waf的技巧今天看Y4师傅发的一个trick，感觉很实用，所以来试一下。  原理就是找到一个类可以把脏数据和我们的gadget包在一起，这个类要实现Serializable接口和储存任意对象。 看要求，其实符合的类就很多了。 测试CC6.java(普通的cc6链子) DirtyDataWrapper.java 确实能够执行。 但也不是所有的集合类都合适，比如LinkedHashSet,HashSet，TreeSet等类就不适合，因为其数据结构有序，如果我们的gadget排在前面则仍可能被waf检测到。"},{"title":"XStream反序列化","date":"2022-02-03T13:14:04.000Z","url":"/2022/02/03/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"XStream反序列化前言 XStream的漏洞很多且中间过程复杂，我这里很简单的看了一下，心中有个概念，所以这篇文章没有任何参考价值。 XStreamXStream是Java类库，用来将对象序列化成XML(JSON)或反序列化为对象。 序列化和反序列化序列化：XStream.toXML() 反序列化： XStream.fromXML() 写一个接口 实现这个接口 序列化 结果: 反序列化 Converter转换器XStream是自己实现的一套序列化和反序列化机制，核心是通过Converter转换器来将XML和对象之间进行相互的转换。 XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。 转换器的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。 简单地说，就是输入XML后它能识别其中的标签字段并转换为相应的对象，反之亦然。 转换器需要实现3个方法： canConvert方法：告诉XStream对象，它能够转换的对象； marshal方法：能够将对象转换为XML时候的具体操作； unmarshal方法：能够将XML转换为对象时的具体操作； DynamicProxyConverterDynamicProxyConverter即动态代理转换器，是XStream支持的一种转换器，其存在使得XStream能够把XML内容反序列化转换为动态代理类对象 dynamic-proxy标签在XStream反序列化之后会得到一个动态代理类对象，当访问了该对象的com.foo.Blah或com.foo.Woo这两个接口类中声明的方法时（即interface标签内指定的接口类），就会调用handler标签中的类方法com.foo.MyHandler。 XStream反序列化漏洞原理XStream是自己实现的一套序列化和反序列化机制，核心是通过Converter转换器来将XML和对象之间进行相互的转换，这便与原生的Java序列化和反序列化机制有所区别，因此两者的反序列化漏洞也是有着很大区别的。 XStream反序列化漏洞的存在是因为XStream支持一个名为DynamicProxyConverter的转换器，该转换器可以将XML中dynamic-proxy标签内容转换成动态代理类对象，而当程序调用了dynamic-proxy标签内的interface标签指向的接口类声明的方法时，就会通过动态代理机制代理访问dynamic-proxy标签内handler标签指定的类方法；利用这个机制，攻击者可以构造恶意的XML内容，即dynamic-proxy标签内的handler标签指向如EventHandler类这种可实现任意函数反射调用的恶意类、interface标签指向目标程序必然会调用的接口类方法；最后当攻击者从外部输入该恶意XML内容后即可触发反序列化漏洞、达到任意代码执行的目的。 基于sorted-set的PoC影响xstream版本 1.4.5，1.4.6，1.4.10 ![image-20220128142847518](/Users/fmyyy/Library/Application Support/typora-user-images/image-20220128142847518.png) EventHandler在XStream反序列化中，EventHandler类是一个很重要的类。这个类是InvocationHandler接口的实现类。 这个类中的两个属性 在EventHandler.invoke()-&gt;EventHandler.invokeInternal()-&gt;MethodUtil.invoke()调用链中，会将这两个属性作为类方法和参数继续反射调用，具体细节可以看源码。 com.thoughtworks.xstream.core.TreeUnmarshaller#start方法，通过readClassType根据payload里的标签获取了类，这里为java.util.SortedSet。 convertAnother()函数对java.util.SortedSet类型进行转换。 mapper.defaultImplementationOf()方法找到默认实现类进行了替换，这里为java.util.TreeSet 之后是converterLookup.lookupConverterForType()遍历所有转换器来寻找替换后的类即java.util.TreeSet的对应转换器。 ![image-20220128151735158](/Users/fmyyy/Library/Application Support/typora-user-images/image-20220128151735158.png) ![image-20220128151919540](/Users/fmyyy/Library/Application Support/typora-user-images/image-20220128151919540.png) 获取到了转换器，之后经过一些调用获取xml里标签和内容 看到获取到了动态代理标签，readItem()读取标签内容，在之后会如上面说的，访问到接口，触发了handler标签里的内容，我们这里handler标签为java.beans.EventHandler，之后反射命令执行。"},{"title":"羊城杯2020 A Piece Of Java","date":"2022-01-26T08:14:04.000Z","url":"/2022/01/26/%E7%BE%8A%E5%9F%8E2020APieceOfJava/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"[羊城杯 2020]A Piece Of Java源码逻辑不难，在hello对设置cookie键名为data进行反序列化 问题是用的是seriakiller进行的反序列化，并且用的白名单限制。 虽然题目自带了CC但是因为这个设置没法直接用。 看一下题目给的条件，有个InfoInvocationHandler 这个invoke肯定是能利用的，关键就在这 回到刚刚的hello路由，反序列化之后调用了info.getAllInfo() 再看给的DatabaseInfo类 所以思路很明确，利用动态代理触发InfoInvocationHandler的invoke方法，之后触发connect进行jdbc反序列化 调用链 这里最开始想的是利用恶意mysql读文件的，但貌似某个配置没开所以没成功。 写exp 恶意mysql和jdbc反序列化的利用参考 "},{"title":"SWPU2019-Web5","date":"2022-01-25T15:05:04.000Z","url":"/2022/01/25/SWPU2019Web5/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"[SWPU2019]Web5题目给了个导入导出通讯录的功能，导出为xlsx文件，所以猜测是解析excel引起的xxe 验证一下 对[Content_Types].xml写入poc之后再压缩回去 验证了xxe存在.无法直接读flag，利用java的file协议列目录，没回显的xxe。 evil.dtd内容 看到备份目录，下载。/ctffffff/backups/backup-af7f385c8840f173779124df915b6ebb.zip 读web.xml看到注册了FlagServlet，但没有权限读/flag 看到axis，查看其版本信息 该版本正好有个RCE CVE-2019-0227  这里的post请求包无法打通,因为这洞有前提条件，但xxe可以进行ssrf，尝试get的请求，用文章里第一个就行，路径得改成axis/shell.jsp 访问看见服务成功开启 然后post /axis/services/randomBBB(这里路径对应上面开启的服务名) "},{"title":"yaml反序列化-2","date":"2022-01-25T10:30:04.000Z","url":"/2022/01/25/yaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%962/","categories":[["java","/categories/java/"]],"content":"yaml反序列化-2 漏洞复现JdbcRowSetImpl经典的JdbcRowSetImpl肯定是可以打通的 ScriptEngineManagerScriptEngineManager类用于Java和JavaScript之间的调用。 SPI是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。 当服务的提供者提供了一种接口的实现之后, 需要在classpath下 META-INF/services目录里创建一个以服务接口命名的文件, 文件内容为接口的具体实现类。当其他客户端程序需要这个服务的时候, 就可以通过查找 META-INF/services中的配置文件去加载对应的实现类。 复现写一个PoC类实现ScriptEngineFactory接口，一个static块执行命令。 根据SPI机制的描述，我们在PoC.class类的同级目录下创建文件夹，像这样 javax.script.ScriptEngineFactory内容为我们的类名（不加class） 在PoC.class所在当前目录开http服务 "},{"title":"yaml反序列化-1 yaml基础","date":"2022-01-19T17:05:04.000Z","url":"/2022/01/20/yaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"yaml反序列化-1 yaml基础yaml简介YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，是一个可读性高、用来表达数据序列化的格式，类似于XML但比XML更简洁。 在Java中，有一个用于解析YAML格式的库，即SnakeYaml。 SnakeYaml是一个完整的YAML1.1规范Processor，支持UTF-8/UTF-16，支持Java对象的序列化/反序列化，支持所有YAML定义的类型。 影响版本全版本SnakeYaml 这里用 yaml语法大小写敏感 使用缩进代表层级关系（缩进只能用空格） 对象格式为 key: value 冒号之后有一个空格 一个短横线加一个空格代表一个数组项 还有一种结构为常量 包括：整数，浮点数，字符串，NULL，日期，布尔，时间。 SnakeYaml反序列化Yaml.load(): 参数为字符串或文件，反序列化返回一个java对象 Yaml.dump(): 将一个对象转为yaml文件形式 序列化： !!为强制类型转换为User类。 反序列化： 成功反序列化User对象。"},{"title":"java类加载机制","date":"2022-01-19T13:14:04.000Z","url":"/2022/01/19/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","categories":[["java","/categories/java/"]],"content":"java类加载机制学到后面发现自己还是基础不扎实，回来重新学一下。 类加载机制Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 主要过程就是：加载，验证，准备，解析，初始化,使用,卸载这7个阶段 类加载器主要来学一下类加载器。 简介虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为“类加载器”。 层次网上偷的图 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，通常使用组合（Composition）关系来复用父加载器的代码。 从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 Java 中使用的默认类加载器有以下三种：Bootstrap 类加载器、Extension 类加载器和 System/Application 类加载器。每个类加载器都有一个预定义的位置，它们在预定义的位置加载类文件。 **BootStrap ClassLoader(引导类加载器)：**主要加载 %JDK_HOME%\\jre\\lib 下的 rt.jar、resources.jar、charsets.jar 和 class 等 JDK 类文件，可以通 System.getProperty(“sun.boot.class.path”) 查看加载的路径。Bootstrap 类加载器是所有类加载器的父加载器，它没有任何父加载器。 **Extension ClassLoader(扩展类加载器)：**主要加载目录 %JDK_HOME%\\jre\\lib\\ext 目录下的 jar 和 class 文件，可以通过 System.getProperty(“java.ext.dirs”) 查看加载类文件的路径。Extension 类加载器将加载类的请求先委托给它的父加载器，也就是 Bootstrap，如果没有成功加载的话，再从 jre/lib/ext 目录下或者 java.ext.dirs 系统属性定义的目录下加载类。Extension 加载器由 sun.misc.Launcher$ExtClassLoader 实现。 **System ClassLoader(系统类加载器)：**又叫作 Application 类加载器，它负责从 classpath 环境变量中加载某些应用相关的类，classpath 环境变量通常由 -classpath 或 -cp 命令行选项来定义，或者是 JAR 中的 Manifest 的 classpath 属性。Application 类加载器是 Extension 类加载器的子加载器，通过 sun.misc.Launcher$AppClassLoader 实现。 ExtClassLoader 和 AppClassLoder 继承 URLClassLoader，URLClassLoder继承自ClassLoder，又如上面所说，Bootstrap ClassLoader这个加载器是用C++语言实现，是虚拟机的一部分，不继承自任何类。 类加载的方式 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()两者都会把类的.class加载到jvm中，两者主要区别就是Class.forName()会执行类的static块。，而ClassLoader.loadClass()则不会，但Class.forName()也有可控参数控制是否加载static块。 可以测试一下 这里的获得的类加载器为AppClassLoader Lanucher是入口，放一下Launcher的部分关键源码 在开头执行了System.getProperty(&quot;sun.boot.class.path&quot;) 所以从源码可以看出JVM类加载器的顺序为BoopStrap ClassLoder -&gt; ExtClassLoader -&gt; AppClassLoder。 类加载器的父加载器ClassLoader类有个getParent方法用于获得类加载器的父加载器 不为null则返回parent属性，看看这个属性是怎么来的。 是在ClassLoader的构造函数里来的，也就是说这是可控的。 AppClassLoader和ExtClassLoader都继承自URLClassLoader，但不表明他们的父加载器就是URLClassLoader，父加载器不等同于父类。 回到我们刚刚的测试源码测试一下就知道。 看到AppClassLoader的父加载器不是其父类URLClassLoader而是ExtClassLoader，这应该是在加载时在Launcher里指定的。 双亲委派某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。"},{"title":"解析excel文件引起的xxe","date":"2022-01-18T13:14:04.000Z","url":"/2022/01/18/%E8%A7%A3%E6%9E%90excel%E5%BC%95%E8%B5%B7%E7%9A%84xxe/","categories":[["java","/categories/java/"]],"content":"解析excel文件引起的xxe老洞了 分析复现一下。 编号 CVE-2014-3529 需要poi-ooxml-3.10-FINAL.jar以下版本 复现Microsoft Office 从 2007 版本引入了新的开放的 XML 文件格式，新的 XML 文件格式基于压缩的 ZIP 文件格式规范，由许多部分组成。 把一个excel文件解压就能看到。 对[Content_Types].xml写入poc之后再压缩回去 分析肯定是在解析xml文件时出了问题。 在getPartsImpl()方法里 \u0001 对excel文件解析之后匹配到[Content_Types].xml之后将数据流作为ZipContentTypeManager这个类构造函数的参数 进入ContentTypeManager方法之后调用parseContentTypesFile 该方法对xml数据没有作任何的过滤直接解析导致了xxe"},{"title":"CVE-2019-14439以及[NPUCTF2020]EzShiro复现","date":"2021-12-22T05:14:04.000Z","url":"/2021/12/22/CVE-2019-14439/","categories":[["java","/categories/java/"]],"content":"CVE-2019-14439以及[NPUCTF2020]EzShiro复现CVE-2019-14439是由logback 引起的 jndi 注入，找不到详细分析的文章，对着网上的poc简单看了一下。 在ch.qos.logback.core.db.JNDIConnectionSource这个类里 漏洞原理并不复杂，很清晰明了的jndi注入。 poc [NPUCTF2020]EzShiro一开始没做出来，后来看wp知道附件有pom.xml buu似乎没给 看到有logback 先是shiro的权限绕过来到/json。访问/;/json post一个true看到Jackson jackson+logback 应该就是CVE-2019-14439了,源码应该是用jackson对post的json数据进行反序列化 但遇到个问题，我直接打没有打通，这里好像还需要绕限制。 看了看wp，参考的是这个。文章里有提到  应该是题目jvm版本太高了。得加载题目自带的链子，看到pom里有commons-collections wp里直接用ysomap工具了，还没在比赛里用过这个工具，顺带学一学。  使用这工具必须的是jdk8，并且jdk8版本不能过低 能弹成功，期末考完去研究一下工具源码"},{"title":"2021安洵杯ezjson-wp","date":"2021-12-02T01:14:04.000Z","url":"/2021/12/02/2021%E5%AE%89%E6%B4%B5%E6%9D%AFezjson-wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"ezjson比赛只做了前两道web，这道题没去看了，因为当时看做出来的人不多就去复习了，今天有空看一下题。 fd文件可以泄露 jar文件下到源码。题目环境不出网没法jndi。但题目本身留了加载字节码后门。 fastjson版本1.2.47,有个通杀payload 这里调用到App.Exec的getFlag即可， 这里可以用$ref调用任意的get  为了回显，字节码用老熟人spring通用回显 这里还要绕关键字 fastjson有个特性，遇到\\x和\\u就会解码，所以十六进制绕过 exp s"},{"title":"fastjson反序列化 1.2.22-1.2.47","date":"2021-11-25T01:14:04.000Z","url":"/2021/11/25/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"fastjson反序列化 1.2.22-1.2.47漏洞原理fastjson支持使用@type指定反序列化的目标类，如下演示： EvilClac.java Calc.java 结果： 当未对@type字段进行完全的安全性验证，攻击者可以传入危险类，从而调用危险类对目标机进行攻击。 1.2.22-1.2.24JdbcRowSetImpl适用fastjson版本1.2.22-1.2.24 配合之前的jndi注入 fastjson在序列化时会调用类中各属性的get方法，而反序列化时会调用其set方法。利用点就在set方法里面 这样直接跟下来逻辑还是很明确的，在最后的connect方法lookup了dataSource，dataSource是我们设置的dataSourceName，为我们的恶意rmi服务。所以我们利用set造成jndi注入进行rce。 1.2.24-1.2.47在1.2.25以上的版本中，使用上面的链子会报错 提示autoType is not support. com.sun.rowset.JdbcRowSetImpl 因为加了黑名单和白名单 不仅如此，fastjson还默认关闭了反序列化任意类的操作，需要手动开启才行。 1.2.24-1.2.48这些版本中陆陆续续出现了绕过和针对绕过的补丁然后继续绕过。 1.2.42修复前看到白名单判断的TypeUtils.loadClass里面 如果开头为 [ 或者开头为 L 结尾为 ; 会去掉这些字符之后再加载，再看下面黑名单 判断是否在黑名单内的方法为startsWith，所以绕过方式显而易见 再原来的com.sun.rowset.JdbcRowSetImpl前面加上L后面加上;即可（用 [。的话会解析错误） 之后给1.4.42打了个很愚蠢的补丁 修复后 大致意思就是，假如开头和结尾是L和;就将头和尾去掉，再进行黑名单验证 还将之前的黑名单验证变成了hash的方式，防止安全人员进行研究 再加一层L和;就可以了。 1.2.43对前面嵌套两层的绕过方式做了一个简单粗暴的修复 连续出现两个 L 直接报错。 这个版本的payload 1.2.45这也不能算绕过，应该算是另一条利用链。 需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本 这里我用的3.4.6 payload 在其set方法中 lookup了data_source,且该类本身不在黑名单中，所以绕过。 1.2.25-1.2.47通杀（无需开启AutoTypeSupport） 测试后均可用。 最近太忙了，之后学习一下原理"},{"title":"2021西湖论剑web部分wp","date":"2021-11-21T04:14:04.000Z","url":"/2021/11/21/2021%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91web%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"2021西湖论剑web部分wpOA?RCE?环境没有写的权限，本地有打通环境打不通的情况很多 之后在webmain/index/indexAction.php处 有个包含任意php文件 有个查看phpinfo的 看了之后开着register_argc_argv，尝试包含pearcmd payload 第一步 第二步 4.php内容为 easyupload?source=1看到源码能上传文件有一些限制 文件名不能有p和h，而且内容长度不超过28。可以上传.user.ini，因为长度不超过28，可以为auto_prepend_file=”/flag”使其自动包含/flag，之后找到一个php文件访问就行。看latte模版会生成一个php缓存文件，且文件生成规则如上图，每个版本文件名固定。本地搭环境(要在linux)，去github上找latte测试。简单看一下 加密规则为key的md5结果前十位a:4:{i:0;s:19:”tempdir/index.latte”;i:1;s:6:”版本号”;i:2;a:7:{i:0;s:5:”clamp”;i:1;s:11:”divisibleBy”;i:2;s:4:”even”;i:3;s:5:”first”;i:4;s:4:”last”;i:5;s:3:”odd”;i:6;s:5:”slice”;}i:3;b:1;}所以生成缓存文件名为index.latte–key加密结果.php之后在尝试2.10.4的时候有了结果，文件名为index.latte–6f26bb0dba.php回到题目，构造一个传文件html 先发包 提示上传成功之后访问/tempdir/index.latte–6f26bb0dba.php​ DASCTF{a3cb921465600f49b52b9ac907a38edb} 灏妹的web扫就完事了，访问/.idea/dataSources.xmlDASCTF{09957769e7c24dddefc1ef615539c9ac} EasyTp有个file参数，直接读/etc/passwd提示harcker，伪协议读源码 有个反序列化，要绕parse绕过方法///public/index.php/index/unser?vulvul=绕过之后网上找条链子就行 payload DASCTF{ee6db14d381babe4f78be657ee473cba}"},{"title":"java Filter内存马","date":"2021-11-21T01:14:04.000Z","url":"/2021/11/21/java%20Filter%E5%86%85%E5%AD%98%E9%A9%AC/","categories":[["java","/categories/java/"]],"content":"java Filter内存马去补了点之前javaweb的知识回来看内存马 Tomcat内存马主要利用了Tomcat的部分组件会在内存中长期驻留的特性，只要将我们的恶意组件注入其中，就可以一直生效，直到容器重启。 javaweb三大组件Servlet 在Java web b/s架构中，servlet扮演了重要的角色，作为一个中转处理的容器，他连接了客户端和服务器端的信息交互和处理。简单来说，客户端发送请求，传递到servlet容器，而servlet将数据转换成服务器端可以处理的数据再发送给服务器端，再数据处理之后，再传递到servlet容器，servlet再转译到客户端，完成了一次客户端和服务器端的信息交互。 Servlet是通过Java编写的，因为他也具备了Java的一些特点，比如跨平台性，可扩展性高，然而他的优点不仅仅是局限于语言方面，因为Servlet的出现，可以使我们将JSP页面中的一些JAVA代码移植到Servlet中来，可无疑使前端人员深受喜欢，方便了项目的修改完善，而Servlet的使用也是非常的简单。 Servlet的生命周期有四个阶段，第一个阶段，实例化，会调用构造方法，第二个阶段是初始化，会调用init（）方法，第三个阶段是请求处理，调用service方法，第四个阶段，服务终止也就是销毁阶段，调用destroy方法。 前台如何将数据传递给Servlet？也是非常简单的，只需表单提交就可以轻松完成，Servlet可以使用request.getParameter来接受，传递给前台就可以使用request.setA什么的来赋值。 页面提交的时候有get和post两种方式，这俩种方式都会在Servlet中处理，如果是get则会调用doget，post则会dopost，而同时使用，只需要post调用doget方法就可以。 Filter filter用于拦截用户请求，在服务器作出响应前，可以在拦截后修改request和response，这样实现很多开发者想得到的功能。 filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。 ListenerJavaweb中的监听器是用于监听web常见对象HttpServletRequest,HttpSession,ServletContext 1.监听web对象创建与销毁. 2.监听web对象的属性变化 3.监听session绑定javaBean操作. 内存马随着攻防对抗的博弈愈发激烈，流量分析、EDR等专业安全设备被防守方广泛使用，传统的文件上传的webshll或以文件形式驻留的后门越来越容易被检测到，webshell终于进入内存马时代。 内存马主要分为以下几类： servlet-api类 filter型 servlet型 spring类 拦截器 controller型 Java Instrumentation类 agent型 Filter内存马POC FIlter流程注册一个Servlet之后自定义一个Filter 在web.xml里注册filter 启动tomcat是可以看到 访问/demo 调试一下tomcat是如何调用我们自定义的Filter的 有几个关键的类 FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息 FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息 FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern FilterChain：过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter WebXml：存放 web.xml 中内容的类 ContextConfig：Web应用的上下文配置类 StandardContext：Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper StandardWrapperValve：一个 Wrapper 的标准实现类，一个 Wrapper 代表一个Servlet 在org.apache.catalina.startup.ContextConfig这个类的configureContext方法里面解析了web.xml 来到StandardWrapperValve类里面，这里初始化了一个filterChain 进入createFilterChain方法。 这里先获取web应用context，再从中获取filterMap[]，里面能就能看到我们定义的filter的信息了 下面遍历了filterMaps进入if语句，里面有两个方法matchDispatcher和matchFiltersURL，如果发现符合当前请求 url 与 FilterMap 中的 urlPattern 相匹配，则会进入findFilterConfig方法 ![image-20211130143455233](/Users/fmyyy/Library/Application Support/typora-user-images/image-20211130143455233.png) 从findFilterConfig方法获取配置返回FilterConfig 如果不为null，则把filterConfig加入filterChain 看addFilter 逻辑很简单，遍历已有的filter判断当前filter是否已经存在，如果不存在则加入。 回到StandardWrapperValve类下面调用了doFilter， ![image-20211130145103086](/Users/fmyyy/Library/Application Support/typora-user-images/image-20211130145103086.png) 跟进这个doFilter 调用了internalDofilter internalDofilter里面调用getFilter获取filter之后下面调用其doFilter方法，所以来到了我们自定义的doFilter方法里面。 内存马注入我们的请求会经过 filter 之后才会到 Servlet ，那么如果我们动态创建一个 filter 并且将其放在最前面，我们的 filter 就会最先执行，当我们在 filter 中添加恶意代码，就会进行命令执行，这样也就成为了一个内存 Webshell 入手点再组装过滤链的部分 在createFilterChain方法里面生成过context即StandardContext类，就是一个web应用 所以要想办法获取这个context，获取这个context的方法有很多，想之后再单独记一篇笔记。 获取到context之后能看到三个重要的属性 前面贴过了这三个属性的作用，再放一遍 FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息 FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息 FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern 大致流程如下： 创建一个恶意 Filter 利用 FilterDef 对 Filter 进行一个封装 将 FilterDef 添加到 FilterDefs 和 FilterConfig 创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发） 每次请求createFilterChain都会依据此动态生成一个过滤链，而StandardContext又会一直保留到Tomcat生命周期结束，所以我们的内存马就可以一直驻留下去，直到Tomcat重启 所以最后就形成了POC。"},{"title":"jdk7u21反序列化","date":"2021-11-19T01:14:04.000Z","url":"/2021/11/19/jdk7u21/","categories":[["java","/categories/java/"]],"content":"jdk7u21反序列化前置知识都已经知道，只有一个AnnotationInvocationHandler类之前学CC链的时候用到过，记不太清了，先重新学 AnnotationInvocationHandler 这次利用的是invoke里面的equalsImpl 先进getMemberMethods 通过反射获取了this.type的所有方法，之后进入下面for循环进行调用。所以肯定会调用到TemplatesImpl类的getOutputProperties() 或者newTransformer() 从而加载字节码。 jdk7u21yso里给的调用链 开头是LinkedHashSet的readObject,调用的是其父类HashSet的readObject方法。 写个poc 下个断点调试一下 在readObject里经过一些验证来到put，这里的map此时应该为HashMap 参数为TemplatesImpl 在该readObjcet中会将反序列化的对象put()放入map中（HashSet本质是HashMap），先添加templates再添加proxy。在put()第二次添加proxy的时候，map中已经有了一个TemplatesImpl 第二次put 之后来到这里 这里是一个关键的地方，我们要触发key.equals，这个key为我们的代理对象，所以会触发AnnotationInvocationHandler的invoke。 但前提得满足两个条件 e.hash == hash 为true (k = e.key) == key 为false 特殊的”f5a5a608”e.hash是在生成payload的时候set.add(proxy)计算的 在java.util.HashMap#put添加键值的时候会经过hash函数计算对象hash 而key此时是proxy动态代理对象，要调用它的hashCode()函数需要走动态代理的invoke接口，当调用方法名为hashCode时，会进入hashCodeImpl() 这个方法遍历memberValues这个map对象，然后做了 memberValueHashCode()直接返回var0.hashCode()，也就是直接返回原本对象的hashcode，但是还要走一次亦或，所以要让127 * (key).hashCode()=0，而key为f5a5a608，他的hashcode刚好为0 所以触发了key.equals(k)进入之前的AnnotationInvocationHandler里的equalsImpl。"},{"title":"LADP+JNDI注入","date":"2021-11-18T01:14:04.000Z","url":"/2021/11/18/JNDI+LADP/","categories":[["java","/categories/java/"]],"content":"LADP+JNDI注入除了RMI服务之外，JNDI还可以对接LDAP服务，LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址：ldap://xxx/xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。并且LDAP服务的Reference远程加载Factory类不受上一点中 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。 LADPLDAP全称是轻量级目录访问协议（The Lightweight Directory Access Protocol） LADP主要能储存以下java对象 Java serializable objects Referenceable objects and JNDI References Objects with attributes (DirContext) RMI (Java Remote Method Invocation) objects (including those that use IIOP) CORBA objects 我们主要就是利用的第二点Reference对象，这在之前也学过。 marshalsecmarshalsec是一个可以快速搭建一个恶意的rmi或者ldap server的工具。 测试写一个客户端 用marshalsec搭建ladp服务 编译好的弹计算器的恶意类放web根目录，之后运行客户端 ladp服务也输出了相关信息 这篇我主要是熟悉一下工具的使用，熟悉之后遇到题目不至于不会用工具。"},{"title":"java fastjson基础","date":"2021-11-16T09:14:04.000Z","url":"/2021/11/16/fastjson%E5%9F%BA%E7%A1%80/","categories":[["java","/categories/java/"]],"content":"java fastjson基础fastjson简介Fastjson是阿里巴巴公司开源的速度最快的Json和对象转换工具,一个Java语言编写的JSON处理器。 它采用一种“假定有序快速匹配”的算法，是号称Java中最快的json库。 常见的序列化操作 简单的使用1.将Json文本数据信息转换为JsonObject对象,通过K V的形式获取值 JSONObject的get方法是通过传入的key值匹配返回val的值 2.将JSON文本转换成实体类 先定义一个User类 有两个方法可以进行反序列化，一个是parseObject、一个是parse，先来看看parseObject parseObject 结果 很明显 根据参数的不同，返回的类也不同。 parse这个方法貌似用到的不多,不细说了。 toJSONString "},{"title":"java JNDI","date":"2021-11-16T01:14:04.000Z","url":"/2021/11/16/JNDI%E6%B3%A8%E5%85%A5/","categories":[["java","/categories/java/"]],"content":"JNDI定义JNDI(Java Naming and Directory Interface)，是SUN公司提供的一种标准的Java命名系统接口。为 开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。 现在JNDI已经成为J2EE的标准之一，所有的J2EE容器都必须提供一个JNDI的服务。 看这篇文章了解一下RMI工厂模式  JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接⼝。我们的应⽤可以 通过JNDI的API去访问相关服务提供的接⼝。 我们要使⽤JNDI，必须要有服务提供⽅，我们常⽤的就是JDBC驱动提供数据库连接服务，然后我们配置 JNDI连接 JDK也为我们提供了⼀些服务接⼝： LDAP （Lightweight Directory Access Protocol） 轻量级⽬录访问协议 CORBA （Common Object Request Broker Architecture） 公共对象请求代理结构服务 RMI（Java Remote Method Invocation）JAVA远程远程⽅法调⽤注册 DNS（Domain Name Service）域名服务 漏洞中涉及到最多的就是 RMI ， LDAP 两种服务接⼝ JNDI注入在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。 恶意服务 返回了一个Reference对象，指向 恶意类 编译后放入根目录 客户端受害者 将编译好的Exploit.class放入根目录，运行服务端之后运行客户端 结果 还有个JNDI+LDAP注入，之后记"},{"title":"java RMI基础","date":"2021-11-14T13:14:04.000Z","url":"/2021/11/14/RMI%E5%9F%BA%E7%A1%80/","categories":[["java","/categories/java/"]],"content":"RMI学习继续补之前的笔记 RMI是什么RMI（Remote Method Invocation），远程方法调用。实际上就是在一个java虚拟机上调用另一个java虚拟机的对象上的方法。 RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。（我们可以再之后数据包中看到该协议特征） 在RMI中对象是通过序列化方式进行编码传输的。 RMI分为三个主体部分： Client-客户端：客户端调用服务端的方法 Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果。 Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用。 总体RMI的调用实现目的就是调用远程机器的类跟调用一个写在自己的本地的类一样。 唯一区别就是RMI服务端提供的方法，被调用的时候该方法是执行在服务端。 实例还是从实例下手吧 先写一个接口 这个接口需要 使用public声明，否则客户端在尝试加载实现远程接口的远程对象时会出错。（如果客户端、服务端放一起没关系） 同时需要继承Remote接口 接口的方法需要生命java.rmi.RemoteException报错 服务端实现这个远程接口 这个实现类需要 实现远程接口 继承UnicastRemoteObject类，貌似继承了之后会使用默认socket进行通讯，并且该实现类会一直运行在服务器上。（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法。） 构造函数需要抛出一个RemoteException错误 实现类中使用的对象必须都可序列化，即都继承java.io.Serializable 注册远程对象 之后是客户端 运行Server之后运行Client RMI反序列化利用P神在java安全漫谈里用wireshark详细演示了通讯细节，实际上通讯过程也算是序列化和反序列化的过程，中间调用了readObject和writeObject。 若RMI服务端存在readObject反序列化点。从通讯过程可知，服务端会对客户端的任意输入进行反序列化。 Commons-collection利用rmi调用的例子。 前提： 服务端具有以下特点 jdk版本1.7 使用具有漏洞的Commons-Collections3.1组件 RMI提供的数据有Object类型（因为攻击payload就是Object类型） 服务端 客户端 "},{"title":"2021湖湘杯web部分wp","date":"2021-11-14T12:05:04.000Z","url":"/2021/11/14/2021%E6%B9%96%E6%B9%98%E6%9D%AFweb%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言快期末了这学期准备退役了，下学期继续努力（大二课怎么这么多啊！！！期末考怎么办啊！！！一节课没听啊！！！） 今天上线看看题 easywill这题没啥好说，跟tp3的rce差不多直接 就能文件包含，之后找不到flag，用拟态的的那个包含pearcmd.php就能getshell Pentest in Autumn下个pom.xml附件 看到shiro spring和shiro，shiro版本有点高，没法直接打。 有个actuator泄露 找到这篇博客  下到heapdump就能弄到秘钥，文章里也给了处理脚本 直接访问无法下载，用shiro未授权 /;/actuator/heapdump 成功下载 用文章里的工具找到秘钥，并脚本处理 拿到key就好办了，之后就是cb1的shiro链子配合spring的通用回显即可 Client.java 获得字节码的类：（spring通用回显） 运行client.java payload如下图打shiro "},{"title":"java动态代理","date":"2021-11-11T12:15:04.000Z","url":"/2021/11/11/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","categories":[["java","/categories/java/"]],"content":"java动态代理记一下之前没记的笔记 代理模式代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 静态代理静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 定义一个Person接口，一个hello方法 一个被代理的类，实现Person接口 一个StaticProxy类 同样实现Person接口，内部还有一个RealPerson类，而且同样实现了Person接口，可以使用RealPerson的hello方法 实例测试 代理模式最主要的就是有一个公共接口（Person），一个具体的类（RealPreson），一个代理类（StaticProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，在执行hello方法前想输出日志之类的消息，通过代理模式很轻松就能办到： 动态代理 代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(StaticProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 创建动态代理类会使用到java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口。java.lang.reflect.Proxy主要用于生成动态代理类Class、创建代理类实例，该类实现了java.io.Serializable接口。 实例： hello接口 被代理类，实现hello接口 一个handler实现InvocationHandler接口 动态代理实现 结果 同样的道理 我们可以再加上一个被代理类 结果： 不同的被代理类传入相应的类构造器即可"},{"title":"java反序列化 rome链以及陇原战疫的java题","date":"2021-11-09T12:14:04.000Z","url":"/2021/11/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20rome%E9%93%BE%E4%BB%A5%E5%8F%8A%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB%E7%9A%84java%E9%A2%98/","categories":[["java","/categories/java/"]],"content":"java反序列化 rome链以及陇原战疫的java题陇原战役遇到一道java题，里面有rome依赖，比赛的时候一搜发现是有现成的链子。 参考  RomeROME 是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或 Java 对象。 ROME 兼容了 RSS (0.90, 0.91, 0.92, 0.93, 0.94, 1.0, 2.0), Atom 0.3 以及 Atom 1.0 feeds 格式。 关键类ObjectBean和ToStringBean类和EqualsBean类 起点是hashmap的readObject，终点是在ToStringBean的toString方法 但最后的利用点事这样的 不可控.invoke(可控,NO_PARAMS)` 需要加载字节码来rce，这个之后说 链子调用链 起点就是经典的hashmap调用任意类的hashcode方法。 看看ObjectBean类的hashcode() 可以调用equalsBean的beanHashCode()方法，跟进看看 这里又可以调用ObjectBean的toString() 继续跟 就来到终点了，ToStringBean的toString 但该类有两个toString ，一个无参一个有参，这里调用的无参。 之后无参调用有参 至于这个prefix的赋值及ToStringBean的_obj属性，看一下两个类的构造函数就知道 到最后rce的地方了 因为这个invoke的第二个参数是空的，所以需要tmpl加载字节码来rce。 这里有一个判断 满足这个if才能进入invoke，前面的调用有点复杂，用参考文章的话来说就是 有参toString方法会调用 BeanIntrospector.getPropertyDescriptors() 来获取 _beanClass 的全部 getter/setter 方法，然后判断参数长度为 0 的方法使用 _obj 实例进行反射调用，翻译成人话就是会调用所有 getter 方法拿到全部属性值，然后打印出来。 回顾tmpl调用字节码的过程 起点是getOutputProperties() 是个无参方法，所以链子通了。 写个exp 陇原战疫原题 有个rome依赖 有个黑名单 不能用HashMap和BadAttributeValueExpException，rome链本就用不到BadAttributeValueExpException，HashMap只是为了其readObject里调用hashcode，换成Hashtable即可。 当时题目不出网，因为spring框架，用spring通用回显。 exp： 但这题其实实际上后面有调用toString 所以exp应该还能简化，比赛时直接用了整条链子，能打通，不管了"},{"title":"陇原战疫web部分wp","date":"2021-11-08T02:14:04.000Z","url":"/2021/11/08/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%ABweb-wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"webCheckIN下载源码，看到这里 这里调用wget，并且参数可控，可以直接外带数据，查看绑定路由 尝试访问/wget?argv=1 这里应该是出题人失误，无需登录可直接访问，利用–post-file参数直接外带文件 payload /wget?argv=fmyyy&amp;argv=--post-file&amp;argv=/flag&amp;argv= 服务器开个监听直接打就行 eaaasyphp反序列化，有个file_put_content可以写文件，本地能打通但是题目写不进去，估计没有写的权限，看phpinfo的hint payload ?code=O%3A6%3A%22Bypass%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A4%3A%22Esle%22%3A0%3A%7B%7Ds%3A4%3A%22str4%22%3Bs%3A7%3A%22phpinfo%22%3B%7D 看到有fpm服务，file_put_contents可控，尝试ftp被动模式打fpm 网上找个ftp恶意服务器 生成payload的脚本 生成的payload(弹shell没成功，尝试curl外带数据) 放到恶意ftp服务器即可 vps运行ftp服务器 poc生成： poc EasyJaba反编译一下 不能用HashMap和BadAttributeValueExpException这两个，有remo的依赖 map换成Hashtable就行了 evil.class用spring通用回显的就行了，用下面这个文章里的就行了  "},{"title":"2021东华杯一道java题","date":"2021-11-05T11:52:04.000Z","url":"/2021/11/05/2021%E4%B8%9C%E5%8D%8E%E6%9D%AF%E4%B8%80%E9%81%93java%E9%A2%98/","categories":[["java","/categories/java/"]],"content":"这次东华杯有个个java题，考点还挺有意思的。 看index控制器 有个很明显的readObject() pom.xml是空的，所以要试原生类或者题目给的类。 题目里给了个ToStringBean类。 在toString方法里有个defineClass用于加载动态字节码。 所以要找一个原生类在其readObject方法调用了toString方法。 CC5的链子里就有这样的类。 CC5的重点就是BadAttributeValueExpException这个类，看看他的readObject方法做了什么。 只放一点重要的源码 在下面看的到调用了valObj属性的toString方法。并且valObj是上面get方法获得的，说明其可控。 写exp 字节码的恶意类 服务器开个监听直接打 "},{"title":"长城杯线下赛赛后复现","date":"2021-10-13T04:10:04.000Z","url":"/2021/10/13/%E9%95%BF%E5%9F%8E%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%8E%B0/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"长城杯线下赛赛后复现前言去打了长城杯决赛，结果全程坐牢，果然不联网的web太难了，赛后拿到了两个web靶机的wp，复现一下。 fancyapi目录结构 逻辑很简单，web用的是python的flask框架，然后go写了几个接口处理数据。 看看backend.go 关键就在这里，action要==readFlag，secret==token，这个token的值是在数据库里的，再看 这里是可以造成sql注入的，注出token即可，但有个过滤，比赛时没有绕过去。。。然后基本上都在想办绕过这个过滤了。。 在app.py处 /search路由的提交的数据传入go接口进行数据库查询，也就是上面sql注入的地方，提交方式为json。 vote参数为整数型，关键在name参数处有个isalnum。 绕过方法为多参数，但我比赛的时候尝试了多参数但是没有绕过去。后来拿到了wp，在本地简单复现一下。 搭建一个简单的app.py 因为isalnum的过滤只能提交字母和数字，如图 上面说了多参数，我只想到覆盖，看了wp用的是[]绕过 附上一张比赛时的原图（不是我做的） 这之后还有个过滤 要传入action=”readFlag”但这里对readFlag有过滤 readFlag没法绕，这里是对路由进行绕过，这里判断当请求路径为/flag时才进行下面的判断，所以 %66lag?action=readFlag即可 比赛时觉得无解，现在看来学到了很多，还是太菜了 work一道java题，比赛的时候知道了大致的思路，但没有做出来，赛后复现一下。 主办方后来给了jar包。所以本地复现比较容易。 直接看后台操作 主要是这里。 这里jdbc参数全可控，搭建恶意mysql服务器读文件即可 但在做这个操作前需要登陆admin 看注册这里 如果按照常规的json格式提交，不管什么username都会被替换成hacker 例如 &#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 注册成功，看看表里注册进了什么数据。 所以要绕过正则，这个正则很简单，用大小写或者畸形json数据即可，这里去掉双引号变成 &#123;username:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 可以看到注册成功了。登陆 /login?data=&#123;username:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 登陆成功后来到admin。 先起恶意mysql服务器。 脚本地址  启动脚本访问  读到/etc/passwd 之后读flag就行。 这题应该还可以用jdbc反序列化，之后学了再来试试。"},{"title":"java反序列化-改造CC3攻击shiro","date":"2021-10-03T13:14:04.000Z","url":"/2021/10/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E6%94%B9%E9%80%A0CC3%E6%94%BB%E5%87%BBshiro/","categories":[["java","/categories/java/"]],"content":"java反序列化-改造CC3攻击shiro前言上一篇学了改造CC6，之前学过，CC3链子就是利用TemplatesImpl加载字节码进行反序列化，既然CC6可以改造，那么CC3也可以改造 改造CC3看看原来的CC3 我们要改的仍然是这部分 之前说过，不能有transformers数组，利用LazyMap#get传参的特性构造payload 要改的基本上就只有数组那部分 其余不变。 之后继续学习看看还有没有能够在shiro中使用的链子。"},{"title":"绿城杯-Light1ng WP","date":"2021-10-03T10:34:04.000Z","url":"/2021/10/03/2021%E7%BB%BF%E5%9F%8E%E6%9D%AF%E2%80%94%E2%80%94Light1ng/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"Light1ng战队一、战队信息 名称：Light1ng 排名：16 二、解题情况进不去平台了，没法截图了 三、解题过程Web1.ezphpezphp在关于里看到个Git，所以考虑存在git泄露 index.php里的php代码 由于assert会进行命令执行，且$link_page参数可控，所以此处存在rce 构造闭合： ?link_page=flag.php&#39;, &#39;..&#39;) === true|eval($_POST[&#39;yy&#39;]);// POST传参： 执行成功，蚁剑连接： 在pages目录下拿到flag DASCTF{af5ff99c7f98d528e711acc42fd6b906} 2.Looking for treasure 打开源码 有提示。 下载到源码 审计。 有一处 这里读取了p文件，如果能控制p的值就能实现文件读取。 这个content和req.body肯定是不相同的不用管它 ，所以p的内容最后会在报错信息的content里发出 看看p是怎么来的 config.path给p赋值。所以得想办法控制path的值。 源码里看到 看到这个想到json-schema原型链污染 payload 成功读到了/etc/passwd的内容，猜测flag在根目录，直接读/flag 数据包 DASCTF&#123;5117143e660f592adc982dd96d2c3f17&#125; PWN1.null正常的菜单堆题，off-by-one漏洞，我没可以看见edit和add中都有read_input（）函数，而漏洞点就在这个read_input（）函数中 可以看见a2+1多读了一个字节我们可以利用这个漏洞来改写chunk的大小造成堆块的重叠。 Exp： 2.uaf正常的菜单题 漏洞点在，free后指针没有置0，造成uaf漏洞，直接freechunk泄露libc，打malloc_hook Exp： 3.Greentownnote这个题的漏洞在于dele这个操作，并没将ptr+8置0 在这可以看到有沙箱函数禁用了exevce，只能读取flag 整体逻辑如下，有正常的add，dele，show功能 直接doublefree泄露libc，利用libc中的函数context可以对其进行栈迁移，我们在堆上提前布置好rop，在利用free_hook函数触发，context+53，将栈迁移到我们布置好的rop处，然后利用srop将rip指向syscall，读取flag 完整exp： RE1.easy_re程序不难，丢入OD，进行分析 发现仅仅是单纯的xor加密,这就好办了,只需要把加密数据dump出来，然后在dump回输入内存，即可让他自动解密（取了个巧，算法没看，猜测可能是RC4魔改） 加密数据如上图 Dump过去，程序自动解密即可 2.[warmup]babyvxworksIDA上来就开幕雷击 很明显，这是一个花指令,直接nop掉 手动处理完，类似上图的所有花指令后，直接IDA F5 Helloworld干了个啥，我也不晓得，但是,算法很明显，就是递归异或0x22，并加3，直接写脚本跑 flag: 3.抛石机先搞清程序如何执行成功 很明显，就是要让x&lt;=y-0.001 z&lt;=d-0.001且要满足那4个一元二次方程，因为不论是v1,v2,v3,v4的取值范围都很小，无限接近于0，不妨设v1=v2=v3=v4=0，然后解这4个一元二次方程(还是在线解吧:)，解得4个值:x1 = 1.08 , x2 = 4.33,x3 = -0.48 , x4 = 1.98，这是4个双浮点数，将他们转为字节 其余3个也是如上图这样转换，然后根据x&lt;=y-0.001 z&lt;=d-0.001，可知x=1.08,y=4.33,d=1.98,z=-0.48 回到开始，这里其实是一个格式的固定，判断是否为flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}格式的flag，并不是照抄,x仅仅代表的是任意字符 全局变量初始化 运算结果，然后进行比较 这里通过动调不难发现规律，输入:13,返回结果就是13，输入ab，返回结果就是AB。 当然这里有个细节得注意，这里仅仅只操作了4个字节，而我们运算的双浮点数是8个字节，很明显不满足我们的条件，所以是算法的问题吗？No，其实后面4个字节，对整体双浮点数的影响微乎其微，所以我们可以舍弃掉，毕竟，他毕竟的是一个范围，而不是一个确切的数字，所以经过计算(我是手工，别骂，flag好像有多组，不知道是不是题的bug):flag{48e17a14-52b8-1e85-b81e-85ebae47e17a} Crypto1.RSA-1易知n,c都是p的倍数,求两者公倍数即可得到p,后面简单求RSA即可 from gmpy2 import * from Crypto.Util.number import * n = 173652311549263483644782768725584927759117606030023943537236034618984057402347150 018201115486009149076170038066524923916867102562741566778871019971756922777296484 560875349876167437246465982344660947795407294135838263551452779804790401570754536 942505723166383481215712187597695337387215068111758669908519728384663075942262938 369341166596852157756432854658953177558927544733320342344957959361836105695710164 005353627626995176867816023020450485321314260352608789798921694410594676235230605 692855705771992363098881558330137219979339604577846532620761355617698387041668103 84309655788983073376941843467117256002645962737847 c = 694496710881543773542894128678411940313831971345573215592505592864653696259767294 180583131213068933801491345208129640027286271044720726509975040165782816583601312 284865683910085471996518868009737549119324912772559966038374682703180306602649798 929885642021625020603506818096379745479215119107143364594624591491673263700711708 519944289449566745554451748340400653660712148067868800042042228138053936851980716 217509976389198864811793777795106989997526019001899583490454144756271830743390659 202122666688563887702030400561445076308133708283860841475616225382569742049350991 4578546951634127502393647068722995363753321912676 p=gcd(n,c) q=n//p phi=(p-1)*(q-1) `e=65537 d=invert(e,phi) M=powmod(c,d,n) m=M//2021//1001//p print(long_to_bytes(m)) flag: 2.Warmup仿射加密,简单逆一下就行 flag: 3.RSA_plus第一部分n1是四个素数的乘积，其中$p和p_1,q和q_1$相近，将n1放入在线网站factordb中分解得到N1和N2，通过开根爆破的方式运行很久都没有出答案，于是可以猜测N1和N2不是由$pp1和qq1$得到，而是$pq1和p1q$得到，假设$p_1=p+p_0;q_1=q+q_0$，通过$(N_1-N_2+p_0q_0)^2+4p_0q_0N_2=(pq_0-p_0q+p_0q_0)^2+4p_0q_0N_2=(pq_0+p_0q+p_0q_0)^2$知，我们可以爆破$p_0,q_0$计算$(N_1-N_2+p_0q_0)^2+4p_0q_0N_2$是否为完全平方数来判断$p_0，q_0$是否为我们所求，这可以用$gmpy2$库里的iroot函数实现。找到$p_0,q_0$后求出p,q,p1,q1，然后通过欧拉函数的积性知$\\varphi(n1)=(p-1)(q-1)(p1-1)(q1-1)$，解出第一部分的flag1。 第二部分已知p2,q2之和,p2,q2之积，可通过求$x^2-(p_2+q_2)x+p_2q_2=0$的两个根得到p2,q2，再通过欧拉函数对素数幂的表达式$\\varphi(n2)=(p_2^2-p_2)(q_2^3-q_2^2)$求得，然后正常的RSA解密得flag2，最后将flag1和flag2合并即可 flag: Misc[warmup]音频隐写下载附件，丢入010分析，发现是WAV的文件头，于是把附件的后缀改为.wav 修改完之后，得到一段音频文件，既然题目提示了音频隐写，那就用Audacity打开这段音频分析一下 音频没发现有什么隐藏信息，于是 打开频谱图看看 得到flag: 创新技术无"},{"title":"java反序列化-TemplatesImpl在Shiro中的利用","date":"2021-10-03T10:14:04.000Z","url":"/2021/10/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-TemplatesImpl%E5%9C%A8Shiro%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/","categories":[["java","/categories/java/"]],"content":"前言有段时间没学java了，最近被一堆事情和比赛拖着，国庆假期正好继续补一下java java反序列化-TemplatesImpl在Shiro中的利用之前已经知道如何将TemplatesImpl 融合到Commons-Collections利用链中，执行任意Java字节码。 这次要解决一个问题：为什么已经有CC6这种高版本通杀链了还需要TemplatesImpl的链子呢？ 可以用shiro反序列化来测试TemplatesImpl反序列化。 shiro反序列化的原理测试之前先添加一波依赖 为了让浏览器或服务器重 启后用户不丢失登录状态，Shiro支持将持久化信息序列化并加密后保存在Cookie的rememberMe字 段中，下次读取时进行解密再反序列化。但是在Shiro 1.2.4版本之前内置了一个默认且固定的加密 Key，导致攻击者可以伪造任意的rememberMe Cookie，进而触发反序列化漏洞。 使用CommonsCollections6攻击Shiro p神自己做了个小demo方便我这种菜鸡学习 demo下载地址  maven打成war包后放入tomcat的webapp目录即可。初始密码root/secret 登录时勾选remember me。 勾选之后登陆cookie会生成rememberMe字段，之前说了这个字段被发送到服务端进行反序列化，所以我们的攻击流程 使用以前学过的CommonsCollections利用链生成一个序列化Payload 将payload用shiro默认key加密 将加密后的payload放入rememberMe字段发送给服务端触发反序列化 可以用下面代码生成cc6的payload 将生成的payload直接打入会报错 p神自己经过调试给出结论：如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。 我们的payload里就有数组 解决办法我们不能用到数组，回忆一下，触发反序列化的最关键的点在与LazyMap的get方法 通常Transformer数组的首个对象是ConstantTransformer，我们通过ConstantTransformer来初始化 恶意对象。 但是此时我们无法使用Transformer数组了，也就不能再用ConstantTransformer了。还记得ConstantTransformer类的作用吗，在学cc1的时候提到过。 这起到一个简单的参数传递作用，那我们能不能找到代替这个作用且不需要数组的利用点呢。 再来看看LazyMap的get方法 我们以往构造CommonsCollections Gadget的时候，对 LazyMap#get 方法的参数key是不关心的，但此时发现，这个 LazyMap#get 的参数key，会被传进transform()，实际上它可以扮演 ConstantTransformer的角色，所以我们最后的难题也解决了 改造CC6为CCShiro 通过Client.java生成payload（别忘了写个Evil类用来获取字节码） 这里用到了javassist，这是一个字节码操纵的第三方库，可以帮助我将恶意类生成字节码再交给 TemplatesImpl 。 "},{"title":"蓝帽杯_one_Pointer_php复现","date":"2021-09-28T01:14:04.000Z","url":"/2021/09/28/%E8%93%9D%E5%B8%BD%E6%9D%AF_one_Pointer_php%E5%A4%8D%E7%8E%B0/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"下载源码 这里溢出即可，因为$count[]=1相当于在数组末位添加一个键值+1，值为1的数据，当前面的键值为long类型最大值时，+1后溢出造成报错绕过。 poc 之后是命令执行，看被ban的函数。 看phpinfo看到了fastcgi 绕过open_basedir读配置文件 读到了这个 fastcgi开在9001端口 写个shell，蚁剑连接。 这里蚁剑的绕过 disable_functions 插件是绕不过去的。 因为ban了fsockopen函数，插件源码是利用这个函数跟fpm通信的。 但可以改插件源码，把 fsockopen换成pfsockopen，两者没区别。还要改端口为9001. 显示root，虚拟终端执行webshell显示为www-data，直接读文件即可。 "},{"title":"2021第五空间webakwp","date":"2021-09-21T14:10:04.000Z","url":"/2021/09/21/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4webakwp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言挺傻逼的，5道web题全是静态靶机，三道rce题，不知道主办方咋想的。附一张图不过也算是ak了web 总体感觉还不错 webftp这题就要说到搅屎的问题了，我直接扫路径扫到1.txt看到flag，大概是哪位大师傅放的赛后跟别的师傅聊了一下，预期解是github上能下载源码然后看就行。 EasyCleanup源码逻辑很简单，给了phpinfo和任意文件包含这里的 session.upload_progress.cleanup 是off的，不会自动清除session文件那直接传PHPSESSID然后包含就行,都不需要条件竞争。exp 然后包含/tmp/sess_aa传命令即可 pklovecloud简单的反序列化poc 之后源码找flag PNG图片转换器这里利用了ruby的open函数能造成命令执行的特性open函数是借用系统命令来打开文件，且没用过滤shell字符，导致在用户控制文件名的情况下，将可以注入任意命令。 管道字符“|”开头，执行管道字符后面的命令 原题传文件，获得唯一文件名，然后读取文件的base64编码。在读取这里 file可控，但得满足上面的条件，这个限制也不是很严格上传两张图片记住文件名在/convernt处第一步file=|echo &quot;Y2F0IC8q&quot;|base64 -d &gt; 0784368baeb4d0a58b04309f20df6f2e.pngY2F0IC8q是cat /*的base64第二步file=|sh 0784368baeb4d0a58b04309f20df6f2e.png&gt;405391431ca1ac9b33f35add1f4ef55c.png之后读405391431ca1ac9b33f35add1f4ef55c.png拿到flag base64解码即可 补充赛后跟feng师傅聊了一下 发现不用这么麻烦，在上传处即可命令执行可以看到，加密的参数是file[filename]但open的参数file[tempfile]是可控的 所以直接再读这个文件即可 yet_another_mysql_injection能时间盲注，但数据库里啥也没有再看逻辑， 就是查询语句要和查询结果一样就可以了这篇文章很详细原文的payload改一下能用原文的SELECT REPLACE(REPLACE(&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;,CHAR(34),CHAR(39)),CHAR(36),&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;) AS Quine本题有过滤，且是注入，所以得改一下 更改后的：username=admin&amp;password=&#39;UNION/**/SELECT/**/REPLACE(REPLACE(&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;,CHAR(34),CHAR(39)),CHAR(63),&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;)/**/AS/**/a#直接打就行 总结企业组第十三，，akweb的队伍很多，主要还是靠队友的misc re和密码才拿到这个名次，又被队友带飞了"},{"title":"2021祥云杯web部分wp","date":"2021-09-21T13:14:04.000Z","url":"/2021/09/21/2021%E7%A5%A5%E4%BA%91%E6%9D%AF%E4%B8%AA%E4%BA%BAweb%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言体验还行 ezyii说是最新的链子，题目把文件都筛选好了让我们找。写一下我的思路看到RunProcess类 底下有个字符串拼接，可以触发__toString,全局搜索__toString AppendStream下有__toString 并且调用了rewind(),找找看这个rewindCachingStream类这里有，并且还调用了seek方法，seek又调用了read方法,在这个read方法里又调用了一个read方法 我们可以控制$this-&gt;stream为我们想要的类，查找read，最后在PumpStream类里 这个类有read方法 ，read调用了pump pump方法调用了call_user_func，所以可以RCE 就写到这吧 我把链子找完的时候队友已经出了，还告诉我网上有公开的poc，心累，说好的最新呢 安全检测检测127.0.0.1成功了 是ssrf，利用ssrf扫路径扫到了源码 包含一下session文件呗payload: 你的PHPSESSID&amp;payload=成功了 挺奇怪的 源码里ban了反引号我这里却可以用 不管了 flag出了就行。 层层穿透这题做了好久，只会一点java的我靠着github上的一键shell poc做完了第一层反弹shell，github有直接可以利用的工具 弹个shell到自己的公网上。题目提示内网信息搜集到了10.10.1.11:8080,估计是内网web环境，先把附件源码反编译一下，因为题目环境20分钟刷新一次，所以现在本地打对着源码逻辑先登录，账号密码源码里可以直接找到 看到admin/test路由存在fastjson反序列化点。不怎么会java反序列化，但是github上有不出网直接在数据包里回显的一键shellpoc照着github上的readme直接打，发现提示太短，看源码把poc复制两边再打就打通了本地打通了，之后是题目。我花了大部分时间在搞代理 有几个小时吧 最后选择了frp 确实方便frp教程端口转发成功后按照刚刚本地的步骤直接打就行（一定找个时间好好学java） Crawer_z引用了zombie框架，谷歌查找 全网只找到这个框架一篇漏洞漏洞描述攻击者可以在他们的页面中插入JS代码来利用zombiejs代码注入漏洞。如果使用zombiejs 抓取此类页面，则运行爬虫的机器将运行攻击者提供的任意命令。为了比较，jsdom 默认禁用脚本执行。 想办法让题目访问我们准备的恶意页面就行。payload在这个博客里都准备好了，提取一下 改成弹shell的 有了payload，我们要想办法让题目访问我们的恶意页面。看一下源码。在user.js下看到访问/user/bucket似乎会自动访问我们个人信息里设置的bucket，尝试访问。尝试更改bucket设置，先看源码在checkBucket函数下，看到bucket的要求，必须以http:或者https:为开头，且必须包含oss-cn-beijing.ichunqiu.com我们尝试修改前面为自己的公网ip地址点击更新 变回原来的了，并且提示admin会来检查，但在源码里看到这里其实算是更改失败了，admin不会去检查源码里有个重定向到/user/verify?token=${authToken}，我们尝试用队伍token浏览器url输入队伍token修改bucket，但不要点击update，直接在访问我们放入队伍token后的url提示更改成功 看到我们的bucket也被设置成了我们的服务器地址其实这里我还没怎么懂原理，只是试了一下发现可以，那就歪打正着直接用。再访问/user/bucket回显的内容变了，报错404，这是因为我的公网上没有oss-cn-beijing.ichunqiu.com这个文件。到这里思路就很清晰了，我们在公网上放置一个oss-cn-beijing.ichunqiu.com.html恶意文件，然后修改bucket为http://公网ip地址/oss-cn-beijing.ichunqiu.com.html并且这个html文件已经被我们插入了用&lt;script&gt;标签包裹的恶意payload服务器起个监听题目内访问/user/bucket弹成功了。 这次比赛就做了这四道题，做完java那题距比赛结束就1小时了，被队友带飞进了前三十 队友们tql"},{"title":"一条laravel5.1的链子","date":"2021-09-10T13:14:04.000Z","url":"/2021/09/10/%E4%B8%80%E6%9D%A1laravel5.1%E7%9A%84%E9%93%BE%E5%AD%90/","categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":" ## 前言挖一整天才挖出这一条，主要是钻牛角尖了，逮着一个地方使劲找链子。 poc先放poc吧 poc分析。我找的destruct方法是Swift_Transport_AbstractSmtpTransport类的看一下他做了什么。 调用了该类的stop方法 看一下stop 箭头这里可以触发__call方法，之后找__call就可以了。但这个类是一个抽象类，所以用他的子类Swift_Transport_EsmtpTransport。 之后是找__call方法。我找到的是DatabaseManager类，看一下他的__call方法。 调用了该类的connection方法，看一下这个方法。 重点在于$this-&gt;makeConnection方法 可以看到最下面可以调用任意类的make方法。但其实这里本身就有call_user_func方法，但这里的没办法利用，这个等一下说原因。全局找make方法。最后在FactoryBuilder里 该类的make调用了makeInstance再看看makeInstance 可以看到call_user_func了，并且参数全可控。所以我们的链子就通了 一些细节解答一下之前makeConnection方法里的call_user_func为啥不能用。我们看一下他的参数。 第一个参数extensions[$name]是可控的，没有问题，关键是第二个config参数，看一下这个参数是怎么来的。 是该类的getConfig方法来的，看一下这个方法。 return的值是Arr::get方法的返回值，看一下这个方法 可以看到，不管怎么样，返回的都是一个数组。所以这个call_user_func不是很好利用。但应该也有利用的方法，我比较懒就找下面的了。而且正好我们FactoryBuilder里的make方法需要数组作为参数不然就会报错，所以这个config就很好的符合我们的要求但最后的makeInstance方法，因为第三个参数是数组，在执行时会报错。所以时没有回显的，但可以反弹shell或者写文件。我poc里构造的相当于 总结不算很好的链子，利用复杂，构造的参数也很严苛。"},{"title":"java反序列化CC3","date":"2021-09-08T13:14:04.000Z","url":"/2021/09/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20CC3/","categories":[["java","/categories/java/"]],"content":"学习动态加载字节码的时候学到了TemplatesImpl加载字节码的方法。我们也可以利用这个特性进行命令执行。结合之前CC1的手动加载我们可以写一个简单的demo，这里用p神的 这里同样是手动触发的put，我们尝试利用cc1的TransformedMap链子触发。这里我自己写了个poc 当然LazyMap也是可以通的。 但CC3链子的出现自然有他的道理。CC3产生的目的就是为了绕过⼀些过滤器对InvokerTransformer的限制。越来越多的过滤器将InvokerTransformer类加入了黑名单，CC3链就是为了突破这个限制产生的。在ysoserial的CC3链子中能看到一些新东西。可以看到将InvokerTransformer换成了InstantiateTransformer类。并且引入了一个新的类com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter在这个类的构造函数里面 该构造函数的参数为Templates接口，而且我们之前利用的加载字节码的TemplatesImpl类实现了该接口。构造函数在给__transformer参数赋值的时候进行了类型转换并且调用了newTransformer()方法。这个newTransformer()就是我们利用TemplatesImpl加载字节码的起点。但是没有InvokerTransformer如何调用这个构造方法？这里用到了InstantiateTransformer类 InstantiateTransformerInstantiateTransformer类也是一个实现了Transformer接口的类，看看他的transformer方法做了什么。 这里利用反射的机制调用了构造函数。iArgs参数就是我们的TemplatesImpl类。前面说到我们需要调用TrAXFilter的构造函数才能加载字节码，所以我们能利用这个类来调用TrAXFilter的构造方法就可以加载字节码，到此CC3就通了。poc "},{"title":"java动态加载字节码的方法","date":"2021-09-04T13:14:04.000Z","url":"/2021/09/04/java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/","categories":[["java","/categories/java/"]],"content":"讨论方法前先来看看什么是字节码 什么是java字节码严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。但是我们讨论的字节码可以扩大范围——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在我们的探讨范围内。Java的ClassLoader来用来加载字节码文件最基础的方法 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader 就是根据类名来加载类，这个类名是类完整路径，如 java.lang.Runtime 。 方法一、利用URLClassLoader加载远程class文件URLClassLoader是AppClassLoader的父类，该类可以加载远程class文件。正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们这里要利用第三种，协议得是非file，最常见的就是http先创建一个恶意类 在class文件所在的文件夹下用python快速起一个http服务器之后试试能不能用UrlClassLoader加载这个类 成功弹出计算器所以在实战中，我们如果能控制ClassLoader为一个http服务器就能加载恶意类。 方法二、利用ClassLoader#defineClass直接加载字节码不管是加载远程的class文件还是本地的class文件都是经历下面三个方法调用javaClassLoader#loadClass-&gt;ClassLoader#findClass-&gt;ClassLoader#defineClass loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 其核心应该是在defineClass方法，因为这个方法才是最后把字节码转化成真正的java类。我们本地测试一下好了。一个恶意类，弹出计算机 编译成class文件，用shell输出base64编码的字节码之后利用definClass加载 成功弹出计算器 方法三、利用TemplatesImpl加载字节码TemplatesImpl相对于ClassLoader比较底层，但原理是defineClass()在TemplatesImpl内部的静态类TransletClassLoader被重载。 但这个方法是个private方法不能被外部调用，我们继续看看。看到getTransletInstance调用了这个方法，但这仍是个私有方法 继续看最好在NewTransformer方法调用了getTransletInstance，并且这是个public方法，可以外部调用。 调用链是这样的 所以poc就有了，这里放p神的 可以看到poc这里用反射设置了三个参数的值，在源码里可以看到原因_bytecodes是字节码为空的话回返回一个错误_name可以任意赋值，不为空就行 defineTransletClasses()的run方法调用了_tfactory.getExternalExtensionsMap()，_tfactory所以不能为空 值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。所以需要构造一个特殊的类来触发。 成功弹出计算器 TemplatesImpl似乎在fastjson和jackson出现的比较多，以后会学到。 方法四、利用BCEL ClassLoader加载字节码BCEL也是个大知识点，以后重点学习，这里放一下poc。 讨论方法前先来看看什么是字节码 什么是java字节码严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。但是我们讨论的字节码可以扩大范围——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在我们的探讨范围内。Java的ClassLoader来用来加载字节码文件最基础的方法 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader 就是根据类名来加载类，这个类名是类完整路径，如 java.lang.Runtime 。 方法一、利用URLClassLoader加载远程class文件URLClassLoader是AppClassLoader的父类，该类可以加载远程class文件。正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们这里要利用第三种，协议得是非file，最常见的就是http先创建一个恶意类 在class文件所在的文件夹下用python快速起一个http服务器之后试试能不能用UrlClassLoader加载这个类 成功弹出计算器所以在实战中，我们如果能控制ClassLoader为一个http服务器就能加载恶意类。 方法二、利用ClassLoader#defineClass直接加载字节码不管是加载远程的class文件还是本地的class文件都是经历下面三个方法调用javaClassLoader#loadClass-&gt;ClassLoader#findClass-&gt;ClassLoader#defineClass loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 其核心应该是在defineClass方法，因为这个方法才是最后把字节码转化成真正的java类。我们本地测试一下好了。一个恶意类，弹出计算机 编译成class文件，用shell输出base64编码的字节码之后利用definClass加载 成功弹出计算器 方法三、利用TemplatesImpl加载字节码TemplatesImpl相对于ClassLoader比较底层，但原理是defineClass()在TemplatesImpl内部的静态类TransletClassLoader被重载。 但这个方法是个private方法不能被外部调用，我们继续看看。看到getTransletInstance调用了这个方法，但这仍是个私有方法 继续看最好在NewTransformer方法调用了getTransletInstance，并且这是个public方法，可以外部调用。 调用链是这样的 所以poc就有了，这里放p神的 可以看到poc这里用反射设置了三个参数的值，在源码里可以看到原因_bytecodes是字节码为空的话回返回一个错误_name可以任意赋值，不为空就行 defineTransletClasses()的run方法调用了_tfactory.getExternalExtensionsMap()，_tfactory所以不能为空 值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。所以需要构造一个特殊的类来触发。 成功弹出计算器[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ypdjjawo-1632274419328)()]TemplatesImpl似乎在fastjson和jackson出现的比较多，以后会学到。 方法四、利用BCEL ClassLoader加载字节码BCEL也是个大知识点，以后重点学习，这里放一下poc。 "},{"title":"java反序列化CC6","date":"2021-09-04T13:14:04.000Z","url":"/2021/09/04/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20CC6/","categories":[["java","/categories/java/"]],"content":"因为sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变化，导致cc1的链子在8u71版本后无法使用。所以要找一条能在java更高版本使用的链子。 cc6的简化版利用链 p神给的poc CC1是触发LazyMap.get方法进行命令执行，CC6是找到其他调用这个方法的地方。这个类是 org.apache.commons.collections.keyvalue.TiedMapEntry ，在其getValue⽅法中调⽤了 this.map.get ，⽽其hashCode⽅法调⽤了getValue⽅法： 所以又要去找哪里触发了TiedMapEntry.hashCode()。在java.util.HashMap#readObject调用了hashCode该方法最后调用了hash，跟进hash方法看到hash方法调用了hashCode poc里用了个fakeTransformers p神在java安全漫谈反序列化5里讲到了他的作用，主要是为了防止本地调试的时候触发命令执行。 关于poc中的outerMap.remove(“keykey”);去掉outerMap.remove(“keykey”);则无法命令执行，主要原因在expMap.put(tme, “valuevalue”);中expMap是HashMap的实例HashMap.put中也调用了hash，但我们传入的是fakeTransformers，所以对poc产生了一定的影响。 在反序列化的过程中，触发反序列化最重要的LazyMap.get方法中并没有进入if分支里面，所以没有触发transfrom。所以为了让containsKey(key)判断为flase，用outerMap.remove(“keykey”);移除即可。触发transfrom之后的过程就跟cc1时一样的。"},{"title":"java反序列化CC1-3","date":"2021-09-03T13:14:04.000Z","url":"/2021/09/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-3/","categories":[["java","/categories/java/"]],"content":" cc1链的最后了。TransformedMap换成了LazyMappoc 核心主要在于LazyMap类的get方法。 如果传入的参数不存在，则调用factory的transform。可以试着写一个非反序列化的命令执行 弹出了计算机（不知道问什么点开就闪退）调试一下看看 可以看到我们get的test这个key是不存在的，所以进入if调用了factory的transform，这个factory就是decorate方法的第二个参数，看源码就知道。[之后的过程就跟之前的TransformedMap链是一样的。 这里是手动执行的get，我们继续研究反序列化的poc。 动态代理sun.reflect.annotation.AnnotationInvocationHandler 的readObject方法中并没有直接调用到Map的get方法。但是AnnotationInvocationHandler类的invoke方法调用了get 调用AnnotationInvocationHandler的invoke方法，这里用到了java对象代理。动态代理详解可以看这篇文章。不过本地调试一下更能理解过程 其实看名字就能看出来AnnotationInvocationHandler实际上就是个InvocationHandler，所以用AnnotationInvocationHandler对我们的map进行代理，这样调用任意方法都会进入AnnotationInvocationHandler.invoke方法进而触发get实现命令执行 总结勉强看完了，但对代理这一块还不是很熟，找个时间自己学一下"},{"title":"java反序列化CC1-2","date":"2021-09-02T13:14:04.000Z","url":"/2021/09/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-2/","categories":[["java","/categories/java/"]],"content":" 上一篇命令执行是我们手动触发的put方法进行添加新元素，那么真正的反序列化poc呢？看看p神给的poc 不过这个poc我本地算是弹失败了，因为java版本的原因，在Java 8u71以后的版本中，由于 sun.reflect.annotation.AnnotationInvocationHandler 发生了变化导致不再可用。我的版本正好是8u71。不过我来学习思路，也懒的改版本了。 sun.reflect.annotation.AnnotationInvocationHandler触发这个漏洞的核心，在于我们需要向Map中加入一个新的元素。在demo中，我们可 以手工执行 outerMap.put(“test”, “xxxx”); 来触发漏洞，但在实际反序列化时，我们需要找到一个 类，它在反序列化的readObject逻辑里有类似的写入操作。这个类就是 sun.reflect.annotation.AnnotationInvocationHandler源码就不放了，逻辑就是调用了setValue方法，这个方法也能触发TransformedMap里注册的Transform。 关于反射的问题看到前面我们生产Runtime类的时候是直接调用getRuntime方法的[ 但这次的poc不一样，是利用反射调用的 这里涉及到反序列化的条件。1、该类必须直接实现java.io.Serializable接口或者间接从其继承树中实现该接口(也就是他的某个父类实现了这个接口);2、对于该类的所有无法序列化的属性(本文指字段field, 而不是严格意义上的属性property, 下同)必须使用transient修饰。 但Runtime类是没有实现java.io.Serializable接口的，所以不能直接反序列化，但反射能解决这个问题，将 Runtime.getRuntime() 换成了 Runtime.class ，前者是一个java.lang.Runtime 对象，后者是一个 java.lang.Class 对象。Class类有实现Serializable接口，所以可以被序列化。 但是AnnotationInvocationHandler 也不能直接实例化，仍然需要利用反射的机制 总结真累，接下来是CC1的LazyMap，比起TransformedMap似乎LazyMap用的更多"},{"title":"java反序列化CC1-1","date":"2021-09-01T13:14:04.000Z","url":"/2021/09/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-1/","categories":[["java","/categories/java/"]],"content":" 最近入门java安全，看一下最基础的CC1链子（URLDNS已经偷偷学过了）先来看看p神原创的最简代码 这里涉及到几个接口和类，一个一个看 Transformer这是个接口，源码也很简单。 看注释，把一个输入的对象输出，这个对象应该保持不变。 TransformedMap及其decorate方法 decorate中 第一个参数为修饰的Map类，第二个参数和第三个参数都是一个实现了Transformer接口的类，转换Map的键和值，为null则不转换。当被修饰的map添加新元素时会分别触发这两个类的transfom方法，也就是说我们之后只要找到能利用的transform方法即可。具体看下面这篇文章里面的一个例子 ConstantTransformer 构造该类时传入一个对象，并在调用transform时返回该对象，算是一种封装。 InvokerTransformer 该类也实现了Transformer类接口的一个类第一个参数是待执行的方法名，第二个参数是函数的参数类型，第三个参数是这个函数的参数列表。重点在改类的transform方法前面说过，通过TransformedMap的decorate方法可以调用任意类的transform方法，所以InvokerTransformer类中的transform及是我们要找的恶意方法，因为他可以导致任意命令执行。 执行原理也很简单，结合之前学过的反射机制很容易就能看懂。 ChainedTransformer 该类也实现了Transformer接口。其构造函数的参数为Transformer[]。主要逻辑算是一种链式调用。将transformers中多个实现Transformer接口的类串在一起，第一个传入的object为第一个类的transform方法的参数，再将执行结果作为transformers列表中下一个类的transform方法的参数。 理解了这些类，再看看p神的构造里的一段。 这里实例化了Transformer[]列表，在下面作为了ChainedTransformer类实例化时的参数。该Transformer[]包含两个Transformer:第一个是ConstantTransformer， 直接返回当前环境的Runtime对象;第二个是InvokerTransformer，获取了exec方法，里面的Object为参数，即exec的参数，这里就是计算器。 总的分析 这里先实例化了一个HashMap类，再用TransformedMap.decorate修饰该类返回了一个新的Map类。前面说过，再被TransformedMap.decorate修饰过的类中添加新元素时会触发第二、第三个参数的transform方法。利用outerMap.put就添加了新元素。下面的这里第二个参数为null，第三个参数为上面实例化的一个ChainedTransformer类。 ChainedTransformer类的transform方法被触发，参数为Transformer[]类。之后利用ChainedTransformer的transform方法链式调用进行命令执行。 总结这算是个半个CC1链子，因为是手动触发的put方法，接下来学完整的CC1链子"},{"title":"java反射学习-3","date":"2021-08-29T13:14:04.000Z","url":"/2021/08/29/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-3/","categories":[["java","/categories/java/"]],"content":"解决两个问题1.如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？2.如果一个方法或构造方法是私有方法，我们是否能执行它呢？ 第一个问题这里要引入新的反射方法 getConstructor 和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。 获取到构造函数后，我们使用 newInstance 来执行。 ProcessBuilder有两个构造函数： 比如，我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后调用 start() 来执行命令： 上面用到了第一个形式的构造函数，所以我在 getConstructor 的时候传入的是 List.class 。 但是，我们看到，前面这个Payload用到了Java里的强制类型转换，有时候我们利用漏洞的时候（在表 达式上下文中）是没有这种语法的。所以，我们仍需利用反射来完成这一步。其实用的就是前面讲过的知识： 通过 getMethod(“start”) 获取到start方法，然后 invoke 执行， invoke 的第一个参数就是 ProcessBuilder Object了。那么，如果我们要使用 public ProcessBuilder(String… command) 这个构造函数，需要怎样用反 射执行呢？ 这又涉及到Java里的可变长参数（varargs）了。正如其他语言一样，Java也支持可变长参数，就是当你 定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变的”。 对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价 的（也就不能重载）： 那么对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。 所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二种构造函数： 在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给 ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下： 第二个问题这就涉及到 getDeclared 系列的反射了，与普通的 getMethod 、 getConstructor 区别是：1.getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法2.getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了举个例子，前文我们说过Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来 获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例 化对象，进而执行命令： "},{"title":"java反射学习-2","date":"2021-08-26T13:14:04.000Z","url":"/2021/08/26/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-2/","categories":[["java","/categories/java/"]],"content":"上一篇学完了反射的基础，接下来深入学习一下。 在正常情况下，除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用forName就不 需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类 同时，forName()还可以获取内部类 我们通过forName获得类之后用newInstance()来调用这个类的无参构造函数，但有时这个方法会失败，原因可能是： 你使用的类没有无参构造函数 你使用的类构造函数是私有的常见的情况就是 java.lang.Runtime ，这个类在我们构造命令执行Payload的时候很常见，但 我们不能直接这样来执行命令： 因为Runtime类的构造方法是私有的。但还是有方法获取到这个类的，这涉及到单例模式。比如，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连 接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来 获取： 之后获取这个类的方法为getInstance。Runtime类就是单例模式，我们只能通过 Runtime.getRuntime() 来获取到 Runtime 对 象。我们将上述Payload进行修改即可正常执行命令了： Runtime.exec有6个重载，第一个重载，它只有一个参数，类型是String，所以我们使用 getMethod(“exec”, String.class) 来获取 Runtime.exec 方法。invoke 的作用是执行方法，它的第一个参数是：1.如果这个方法是一个普通方法，那么第一个参数是类对象2.如果这个方法是一个静态方法，那么第一个参数是类 这也比较好理解了，我们正常执行方法是 [1].method([2], [3], [4]…) ，其实在反射里就是 method.invoke([1], [2], [3], [4]…) 。 所以我们将上述命令执行的Payload分解一下就是： "},{"title":"java反射学习-1","date":"2021-08-25T13:14:04.000Z","url":"/2021/08/25/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-1/","categories":[["java","/categories/java/"]],"content":"学习java反序列化之前少不了学习反射，虽然之前学过，还是再学一遍 java反射机制的定义Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 java的反序列化问题都基于反射机制 Java 反射机制的功能1.在运行时判断任意一个对象所属的类。2.在运行时构造任意一个类的对象。3.在运行时判断任意一个类所具有的成员变量和方法。4.在运行时调用任意一个对象的方法。5.生成动态代理。 Java 反射机制的应用场景1.逆向代码 ，例如反编译2.与注解相结合的框架 例如Retrofit3.单纯的反射机制应用框架 例如EventBus4.动态生成类框架 例如Gson 反射常见使用的方法获取类的方法：forname实例化类对象的方法：newInstance获取函数的方法：getMethod执行函数的方法：invoke 只有JVM能够创建Class对象 获取class对象三种方法一般我们获取class对象就有以下三种方法 1、类的.class属性第一种就是最简单明了的方式，我们可以通过类名的属性class获取。 2、实例化对象的getClass()方法第二种我们可以先实例化一个对象，之后在调用getClass()方法。 3、Class.forName(String className)：动态加载类第三种则是调用Class类中的forName方法，将字节码文件加载进内存，返回Class对象。 总的来看 结果 但在这三种获取CLass类方式中，我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。 而使用类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误； 而使用实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。 所以我们在获取class对象中，一般使用Class.forName方法去获取。 获取成员变量Field 获取成员方法Method 获取构造函数 利用反射创建类对象（重点）在前面我们获取了Class对象，之后展示了一系列获取成员变量、成员方法和成员函数的方式后，我们现在可以通过反射来生成实例化对象，一般我们使用Class对象的newInstance()方法来进行创建类对象。 使用的方式也特别简单，只需要通过forname方法获取到的class对象中进行newInstance方法创建即可。 利用反射机制创建类并执行方法"}]